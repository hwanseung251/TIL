## 1. 클라이언트와 서버

- **클라이언트**
    
    서비스를 요청하는 주체 → 웹 브라우저, 모바일 앱
    
- **서버**
    
    요청에 응답하는 주체 → 웹 서버, 데이터베이스 서버
    

### 웹 동작 과정

1. 클라이언트가 URL 입력 후 Enter
2. 웹 브라우저 → 서버에 파일 요청
3. 서버 → 데이터베이스에서 파일 찾아서 응답
4. 브라우저 → 전달받은 파일 해석 & 화면에 출력

---

## 2. 프론트엔드와 백엔드

- **프론트엔드**
    
    사용자 인터페이스(UI)를 구성하는 영역
    
    (사용자가 실제로 보는 화면)
    
- **백엔드**
    
    서버 측에서 동작하는 영역
    
    - 클라이언트 요청 처리
    - 데이터베이스와 상호작용
    - 최종 응답 전달
    - 서버 언어(Python, Java) 및 프레임워크(Django), DB, API 등 활용

---

## 3. 프레임워크

- **정의**
    
    웹 서비스 개발 시 로그인, 회원관리, 보안 등 기능을 제로베이스로 개발하면 비효율적 → **빠르고 효율적인 개발을 돕는 도구**
    
- **중요 포인트**
    
    대규모 트래픽 서비스에서도 안정적으로 사용 가능한 **검증된 프레임워크** 선택이 중요
    
- **Django**
    
    파이썬 기반 대표 웹 프레임워크 → Spotify, Instagram, Dropbox 등에서 사용
    

---

## 4. 가상환경(Virtual Environment)

- **개념**
    
    하나의 컴퓨터 안에서 **독립된 파이썬 환경**을 만들어서 관리
    
- **왜 이 환경을 만드는가?**
    - 두 개의 프로젝트를 진행하면 프로젝트 별 **패키지 버전 충돌을 방지할 수 있고**
    - 가상 환경을 만듬으로써 독립적 개발 환경 제공
- **비유**
    
    하나의 집(컴퓨터) 안에서 방(가상환경)을 따로 만들어서 필요한 물건(패키지)을 그 방 안에서만 관리
    
- 그냥 pip install하면 글로벌에 설치하는 것임

### 가상 환경 생성 및 활성화 과정

1. 생성 
    - 가상 환경 생성
        
        `python -m venv(가상환경을 만들겠다 라는 명령어) venv(만들 가상환경 이름)`
        
        - 현재 디렉토리 안에 venv라는 폴더가 생성된다(venv 라는 가상 환경을 만든 것)
        - venv 폴더 안에는 파이썬 실행 파일, 라이브러리 등을 담을 공간이 마련됨
        - 임의의 이름으로 생성이 가능하나 관례적으로  venv이름을 사용
    - 절대로 venv 직접 건들지 말자 명령어로 자동적으로 수정
    - 만들었다고 아직 활성화하지 않은 것. 이동이라기 보단 on off의 개념이다
2. 활성화 
    - 가상 환경 활성화
        
        `source venv/Scripts/activate` (경로는 달라질 수 있음, 그런 경우는 웬만하면 없긴 함 )
        
    - 활성화를 하면 (venv)계속 따라다님. on했다는 뜻
    - 하나를 켰다고 해서 모든 터미널이 가상 환경이 켜지는게 아니라 또 다른 곳에서 가상 환경을 킬 수 있는 것임
    - **on off**의 개념이기 때문에 `cd ..`로 폴더 이동했다고 가상 환경이 꺼진 것이 아니다. 계속 그 가상 환경에서 컴퓨터를 사용하고 있는 것이다
3. 종료
    - `deactivate`로 종료함(터미널을 그냥 닫아도 꺼지긴함)
    - 다시 파이썬 글로벌환경으로 돌아온것

### 의존성

- 각 가상 환경에서는 굉장히 많은 라이브러리 패키지를 설치함 그런데 이게 서로 독립적이지 않고 서로 다른 환경인데 이를 가져다 쓰는 의존적인 경우가 있다.
- 즉 우리는 한 개를 설치했는데 패키지 목록을 보면 엄청 많은 경우가 있음. 하나의 소프트웨어가 동작하기 위해선 굉장히 많은 의존성들이  서로 얽히고 섥혀 있음.
- 여기서 하나의 문제가 생기면 다른 것에 다 문제가 생기는 경우가 있음.

→ 프로젝트가 의존하는 개별 라이브러리들을 **의존성 패키지**들 이라고함(프로젝트가 실행되기 위해 꼭 필요한 각각의 패키지)

1. 패키지 목록 확인 
    
    `pip list`로 현재 가상 환경이 의존하는 라이브러리 목록을 확인 가능
    
2. 의존성 기록
    
    `pip freeze`
    
    라이브러리를 기록해야 함. 다른 컴퓨터로 갔을 때, 이 의존성 기록을 바탕으로 동일한 환경을 만들 수 있음
    
    `pip freeze > requirements.txt` : 의존성 기록을 그대로 텍스트 파일로 옮김 
    
    - venv파일을 가지고 다니는 게 아니라 위에서 만든 txt파일을 공유, 전달을 하는 것(가상환경을 텍스트파일로 간단하게 써논것이기때문)
    - 다른 파일명으로도 가능하나 관례적으로 requirements.txt를 사용
    

### 의존성 리스트 공유 시나리오

1. 두 명의 개발자가 하나의 프로젝트를 함께 개발한다고 가정하면
2. 개발자가 가상 환경을 생성하고 프로젝트를 설정하고 관련 패키지를 설치하고 개발하다가 협업을 위해서 깃헙에 푸시
3. 개발자 B는 해당 프로젝트를 clon받고 실행해보려 하지만 실행 안됨
4. 왜? 어떤 환경 어떤 버전인지 알 수 없기 때문이다.(개발 한 것만 올려서)
5. 가상 환경에 대한 정보 즉 패키지 목록 공유가 필요!

**의존성 패키지 관리가 필요한 이유**

- 패키지마다 버전이 다름
- 프로젝트가 커질 수록 패키지 개수도 늘어나게 됨. 기록 및 공유가 필수

따라서, 다른 pc나 팀원들이 같은 환경을 구성할 때 의존성 리스트가 반드시 필요(venv 자체는 너무 크고 깊다) 

**pip list와 pip freeze**

pip list는 가상 환경을 만들때부터 그냥 존재하는 공유 필요 없는 그런 것도 적혀있음 그리고 그 형태가 문법이 아님. pip freeze랑 문법적으로 기능이 좀 다름. 그리고 패키지를 설치할 때는 pip freeze 문법의 구조여야한다.  

| 단계 | 목적 | 명령어 | 설명 |
| --- | --- | --- | --- |
| **가상환경 생성** | 새 가상환경 만들기 | `python -m venv venv` | 현재 디렉토리에 `venv` 폴더 생성 (이름은 원하는 대로 가능) |
| **가상환경 활성화** | 가상환경 ON | `source venv/Scripts/activate`   | `(venv)` 표시가 붙으면 활성화 완료 |
| **가상환경 종료** | 가상환경 OFF | `deactivate` | 글로벌 파이썬 환경으로 복귀 |
| **패키지 목록 확인** | 현재 가상환경에 설치된 패키지 확인 | `pip list` | 설치된 모든 패키지와 버전 출력 |
| **의존성 기록** | 설치된 패키지를 텍스트 파일로 저장 | `pip freeze > requirements.txt` | 협업 시 이 파일로 동일한 환경을 재현 가능 |
| **의존성 설치** | requirements.txt 기반 패키지 설치 | `pip install -r requirements.txt` | 팀원이 동일한 개발환경 세팅 시 사용 |

### 가상환경 주의사항

- 가상 환경은 들어가고 나오는 것이 아니라 python환경을 on/off하는 전환 개념이다
- 가상 환경 활성화는 현재 터미널환경에만 영향을 끼치기 때문에 새 터미널 창을 열었으면 다시 활성화 해야 함
- 프로젝트마다 별도의 가상 환경을 사용하고 가상 환경은 그 폴더에서 생성함. 그래서 A프로젝트의 가상 환경이 있는 거고, B는 또 다른 가상 환경이 있는 것
    
    → 각자의 폴더에 하나의 가상 환경을 두니까 venv1,2라고 명칭을 구별할 필요가 없는 것이다.
    
- venv는 관련된 프로젝트와 동일한 경로에 위치하고 중요한 것은 venv를 켜는 위치가 중요한 것이다
- 폴더 venv는 gitignore파일에 작성되어 원격 저장소에 공유하지 않도록 한다.

### 가상환경이 필요한 이유 정리

1. 프로젝트마다 다른 버전의 라이브러리 사용
2. 의존성 충돌 방지
3. 팀원 간 협업(누구든지 동일한 방식으로) 

**Django 프로젝트 실습**

- Django 프로젝트 생성 및 서버 실행해보자

**과정 3단계**

1. 장고 설치
    
    `pip install django` → 버전을 지정하지 않으면 최신 버전이 설치됨 (현재 장고 5.2.6버전)
    
    (지금 가상 환경에서 설치했으니 글로벌 환경엔 장고가 없다)
    
2. 프로젝트 생성
    
    `django-admin startproject(목적) firstpjt(프로젝트의 이름) .(현재 디렉토리)`4
    
    - `admin` 은 관리 명령어 세트를 실행한다는 의미를 갖고있다.
    - `.`없으면 필요하지 않은 폴더까지 만들어서 그 안에 만들어줌. 그래서 `.`쓰는것이 좋음
    
    <aside>
    
    앞으로 명령어들은 하나씩 끊어서 각 의미를 이해하면서 외우도록 하자.
    
    </aside>
    
3. 서버 실행
    
    `python [manage.py](http://manage.py) runserver`(서버를 가동할거다)
    
    - 장고 서버가 방금 켜짐.
    - 우리가 직접 `127.0.0.0:8000` 주소에 요청을 보낸 것
    - 그 응답으로 장고 서버가 로켓페이지를 준것

      이 서버의 통신 과정을 항상 이해하면서 공부해야 한다! 모든 것은 요청과 응답이다!

서버를 키면 서버 log를 확인할 수 있다. (요청하면 계속 서버에 요청했다는 로그가 쌓임)

서버를 끄고 요청하면 당연하게도 페이지를 받지 못한다.

서버가 켜져 있을때, 다른 서버를 켜서 요청하면 이전 서버로 요청이 가니까 꼭 `ctrl c`로 꼭 끄자

### 디자인 패턴

소프트웨어 설계에서 반복적으로 발생하는 문제에 대한 검증되고 재사용 가능한 일반적인 해결책

관습이지만 따르는게 좋음. 

**MVC 디자인 패턴**

- 하나의 애플리케이션을 구조화하는 대표적인 구조적 디자인 패턴
- Model
    - 데이터 및 비즈니스 로직을 처리
- View
    - 사용자에게 보이는 화면을 담당
- Controller
    - 사용자의 입력을 받아 Model과 View를 제어

“Python은 파이써닉한 코드다 !“라고 해서 다른 언어들이랑 다르게 말을 듣지 않는 면이 있음

- 예를 들어 배열을 모두가 array라고 하는데 파이썬은 list라고 부름

근데 장고가 파이썬 기반이니까 이와 비슷하게 모두가 MVC라고 하는데 장고는 MTV라고함 (Model, Template, View)

- 기존 MVC패턴과 동일하나 단순히 명칭을 다르게 정의한 것이다.
- 장고의 해명 FnQ가 있긴 함. 왜 본인이 이름을 이렇게 했는지

### 프로젝트와 앱

프로젝트는 큰 틀에서 동작할 때 큰 설정을 담당함(기능말고) 프로젝트의 기반인 것

여기에 기능이 필요한데..(로그인, 보안, 게시판 등 ..) 누가 담당해? **앱**이 담당한다.

- 장고에서 프로젝트는 여러 애플리케이션의 집합
- 이 각각의 애플리케이션은 독립적으로 작동하는 기능 단위의 모듈

> 만약 카페 프로젝트를 만든다
> 
> 
> “커뮤니티를 만든다“라고 한다면 `게시글` `댓글` `회원관리` 가 필요하고
> 
> “쇼핑몰 프로젝트를 만든다”라고 하면 `상품조회` `배송조회` `결제` 이렇게 기능 단위로 앱을 만들게 될 것이다(개발자의 선택 기준으로 나눔)
> 

### 최종 목표: 게시판이 주가 되는 커뮤니티를 만들어보자

1. 생성
    - 앱을 생성해보자.
    - 게시판 기능을 만들어보자 → 이름을 articles(앱 이름은 복수형으로 지정하는 것을 권장)
    - `python [manage.py](http://manage.py) startapp articles`

> 상하 관계가 프로젝트 안에 존재하는 앱 인거지 물리적인 폴더 구조는 아니다
> 
> 
> 프로젝트 안쪽에 articles가 위치하지 않음. 프로젝트 폴더와 앱 폴터는 동일한 선상에 있다
> 

그렇다면…

- 컴퓨터 입장에서 생각해보면 동일한 경로잖아.
- 그러니까 서로 독립된 폴더. 프로젝트는 articles라는 폴더가 생겼는지 알지 못함.
- 그래서 앱을 만들고나서 등록을 해야 함. 프로젝트한테 articles라는 앱 만들었으니 포함 시키라고 해야 한다

→ [**settings.py**](http://settings.py) 프로젝트 설정을 관리하는 파일 (**여기에 어딘가 등록을 해야 함)**

- 이 파일안에 `INSTALLED APPS`라는 리스트가 있는데 보면 6개의 app이 있다.
- 이건 내장 app임
- 여기에 우리가 만든 `articles`라는걸 등록 하면 됨(문자열로 작성. 약속)
- 사용자가 생성한 앱은 리스트 상단부터 작성하는 것을 권장(장고의 내부 구동 순서 때문에, 약속)

**프레임워크를 쓸땐 약속들을 좀 암기를 해야 함**

1. 앱 등록
- 순서가 중요한데 생성하고 등록하자
- 등록을 먼저 하게 되면 `startapp`했을 때 만들어지지 않는다.

- 프로젝트 구조
    - settings.py
        - 모든 설정을 관리
    - urls.py
    
    이 두 개 파일은 주구장창 쓸 것이다(수업하면서).
    
    - **__init__**.py  해당 폴더를 패키지로 인식하도록 설정하는 파일
    - [asgi.py](http://asgi.py) [wsgi.py](http://wsgi.py) aws 같은데에다가 업로드하려면 그때쓰는 파일들
    - [manage.py](http://manage.py) 쓰지는 않는데 명령어로는 씀 장고 프로젝트와 다양한 방법으로 상호작용하는 커맨드라인 유틸리티임
    
    이 네 개 파일은 수업 과정에선 수정할 일이 없다
    

- 앱 구조
    - admin.py
        - 관리자용 페이지 설정
    - [models.py](http://models.py) (중요)
        - DB와 관련된 Model을 정의
        - MTV 패턴의 M을 담당
    - [views.py](http://views.py) (중요)
        - MTV패턴의 v를 담당

**그럼 T는 어디있을까?**

- T는 사용자에게 보여지는 것을 담당하는데 장고 자체가 풀 스택 프레임워크이긴 하지만 백엔드 전용이다
- 그래서 프론트쪽은 장고보다 잘할 수 있는애들이 많음.  장고 자체가 백엔드에 특화되었기 때문에 T는 처음에 만들어주지 않고 직접 생성 해야 함
    - [apps.py](http://apps.py)
        - 앱의 정보가 작성된곳
    - [tests.py](http://tests.py) 이 두개는 따로 열일은 없을 것이다.

**요청과 응답**

- 장고는 서버니까 요청을 받아서 그것에 대한 일반적인 처리를 해서 응답 결과를 줌
- 주소에 **articles/** 라는 주소를 붙여서 요청하면(메인페이지로 만들 주소) `urls.py` 라는 입구로 전달됨
- `urls.py`는 이 주소를 받아서 분석을 함, “아 이거 메인 페이지달라고 설계한거네.”
- 그 다음에 `views.py`한테 시킴.
- 뷰에 있는 어떤 함수를 호출을 함 .
    - 그래서 대부분의 코드를 여기에다 작성할 것이다. 뷰는 controller이니깐. 이 안에는 함수들이 있는데 여기에 수많은 뷰 함수들이 만들어짐
    - 어떤 함수는 메인 페이지를 가져와서 응답 어떤함수는 로그인 어떤함수는 로그아웃 등

**과정 요약**

주소가 요청이 오면 `urls.py`가 받고 분석 → `views.py`한테 호출 → `models.py`가 필요하면 소통하고 `templates`이 있으면 소통하고 응답(함수의 return 즉 결과물)을 줌. 

### 코드작성으로 이를 살펴보자

- 입구인 [`urls.py`](http://urls.py) 로 들어가면 import가 있고 뭔가 리스트가 있음.
- 여기에 문자열로 `admin/`가있는데 이것은 주소임(path안에는 ~8000 포트 뒤에 나오는 나머지 주소를 적는 것(약속)). 저 주소로 요청이 오면 처리할게 하나가 있는 것이다.

한번 이 주소로 요청을 보내보면 관리자 페이지 로그인 화면이  나온다

> 만든적이 없는데…? → 기본적으로 들어가 있는 것임. (로그인은 안됨. 아직 admin을 만들진 않았기 때문)
> 
> 
> **즉 path안에 주소는 입구라는 것이다.** 클라이언트가 요청을 하면 **주소를 여기에서 매칭** 시키고 매칭 되면 뒤에 있는 **뷰 함수를 호출**하는 것이다. 
> 

- 여기에 `articles/`를 컨트롤해보자. 이거를 메인 페이지 주소로 쓰고 싶다.
- 리스트안에 path를 꼭써야함. 이거는 약속. (문자를 받고 뷰 함수 호출하는  메서드가 path함수인데 이미 import되어있음)
- path는 첫 번째에 있는 url이 `articles`까지 일치 되었을 때 → **두번째 인자에 있는 view함수를 호출**

> 근데 view함수를 `urls.py`에서 호출하려고 보니 `urls.py`는 `firstpjt`폴더에있고 이와 같은 선상에 있는 폴더인 `articles`폴더 안에 `views.py`가 존재함.
> 
> 
> → 파이썬은 이를 패키지, 모듈로 보기 때문에, `import articles import views` 하면 가져올 수 있음  
> 

- 그럼 이제 **views.py** 들어가서 함수 하나 만들자
- `def index()`: # 메인 페이지를 응답하는 함수를 만들자. return은 render함수의 결과를 반환할 것임

> render: 렌더링한다라고하는데 템플릿을 만들어내는 친구임
> 
> 
> 모든 뷰함수는 첫번째 인자로 요청 덩어리 객체를 필수적으로 받음(예외없이) 선언안하면 동작 안 함. 
> 
> 이 요청 덩어리는 urls가 요청 덩어리임. 이를 그대로 전달 받는것을 표시하는 것이다. 
> 
> 이 요청덩어리를 받는 위치는 매개변수라서 매개변수이름은 request가 아니어도 되지만 관례적으로 request로 작성하자
> 

- 이제 렌더함수를 반환 하는걸 작성해보자.
- 첫번째 인자는 아까 언급하였듯이 역시 request넣고
- 렌더의 두번째 인자는 템플릿 경로를 넣자.
    - 렌더가 하는 일은 템플릿 하나를 잘 조합해서 응답하는 것.
    - 그럼 템플릿이 어디있냐가 중요한데 그 경로는 두번째 인자로 들어감.

아까 언급했듯이 템플릿은 사전에 만들어주지 않았음. 

그래서 앱폴더 안에 만들어주자. 

- 이름은 `templates`로 만들자(약속임)
    - 이후에 경로는 상관없음.
- 이안에 html파일을 만들고 간단하게 h1태그에 “메인페이지입니다”라고 해보자
- 이 재료를 view함수에서 쓰는 것이다. 그래서 view함수 두번째 인자에 이 파일의 경로를 적으면 된다.
- 그리고 [`urls.py`](http://urls.py) 안에 있는 리스트 안에 path에 요청 주소와, 그리고 뷰함수를 넣어 호출한다.
    - 여기에 views.index하면됨. ()는 쓰면안됨.
    - 왜냐면 지금 호출하는 게 아니라 요청이 들어오면 호출할 거라서. 함수에 이름만 넣어주고 대기 상태로 두는 것이다.

<aside>

지금 흐름이 URLs → View → Template로 가고있는데 코드 작성도 이흐름으로 하자

왜냐면 나중에 디버깅할때 힘들어짐

문제원인을 역추적해야하는데 보기 어려워짐. 이것도 약속임

</aside>

### 참고

.gitignore를 생성하고  생성전에 venv가 깃에 한번 관리가 되었었으면 gitignore에 넣어도 명령어 없이는 안빠진다, 그래서 첫 add 전에 `.gitignore`를 세팅을 하는게 가장 좋다.

그래야 venv가 정확하게 빠지게됨

**LTS**

장고는 메인머전을 ~.2로 끌고감. 장기간 지원되는 안정적인 버전을 부를때 .

LTS는 기본적으로 3년이상 지원한다. 파이썬 3.11기준 최신버전이 5.2임  만약 파이썬이 3.9였으면 4.2가 설치됬을거다.

버전을 명시하려면 pip install ==버전 이렇게 하면된다. 

render함수는 주어진 템플릿을 주어진 컨텍스트 데이터와 결합하고 렌더링 된 텍스트와 함께 HttpResponse응답 객체를 반환하는 함수이다.  요청객체 덩어리를 템플릿이름의 경로로 전달하는 역할을 한다. 

1. requset
2. template_name
3. context(템플릿에서 사용할 데이터, 딕셔너리 타입으로 작성)

**지금까지 등장한 장고의 규칙**

1. urls.py에서 각 url문자열 경로는 반드시 ‘/’로 끝난다, 없으면 동작안함
2. views.py에서 모든 view함수는 첫번째 인자로 요청인 request가 있어야한다. 이게없으면 뷰함수가아니라 일반함수임
3. 장고는 특정 경로에 있는 template파일만 읽어올 수 있음 
    - 특정 경로: app 폴더/templates (약속된 경로임) 그 뒤는 자유

**프레임워크의 규칙**

프레임워크를 사용할때는 일정한 규칙을 따라야 하며 이는 저마다의 설계철학이나 목표를 반영하고있음

일관성유지 보안강화 유지보수성향상 최적화등과 같은 이유

도구와 환경을 제공하기 위해서 규칙을 정해놓은것이며 이를 잘 활용하여 표준화 단순화 할 수 있도록 해야함