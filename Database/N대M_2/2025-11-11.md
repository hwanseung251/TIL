# 팔로워 기능을 위한 N:M 관계 구현

## 프로필 페이지

- 개인 프로필에 팔로우 기능을 구현하기 위해 프로필 페이지를 만들어보자
- 프로필 페이지에 들어갈 내용
    - 해당 사용자가 작성한 게시글 목록
    - 해당 사용자가 작성한 댓글 목록
    - 해당 사용자가 좋아요를 누른 게시글 목록

### 프로필이니까 accounts/urls.py에 주소 작성

- 문자열로 시작하는 변수 라우팅 주의하기
- 고정된 `profile/` 등의 주소를 추가해서 다른 경로보다 먼저 매칭되어 정상적인 경로 탐색이 막히는 문제를 방지

```python
from django.urls import path
from . import views

app_name = 'accounts'
urlpatterns = [
    path('login/', views.login, name='login'),
    path('logout/', views.logout, name='logout'),
    path('signup/', views.signup, name='signup'),
    path('delete/', views.delete, name='delete'),
    path('update/', views.update, name='update'),
    path('password/', views.password, name='password'),
    # <username> 이라고해도됨 str은 기본값.
    # 문자열로 시작하는 variable routing 은 사용시 주의해야함
    # 왜냐면 이걸 맨위에 넣으면 다른 밑에 있는 정상 경로들을 안찾을 수 도 있기 때문에,,,
    path('profile/<str:username>', views.profile, name='profile'),
```

### view 함수 작성

- context 에 `user` 이름으로 넘기지 않는 것을 권장한다.
    - 왜냐하면 Auth에서의 user와 곂치기 때문

```python
def profile(request, username):
    # 해당 프로필 페이지의 유저를 조회
    # user모델의 참조 방법
    # 장고 실행순서에 따라 form에서는 get_user_model() : 현재 사용되는 유저모델쓰는거
    # models.py에는 AUTH_USER_MODEL 문자열 사용 
    User = get_user_model()
    person = User.objects.get(username=username)
    # auth에서 쓰는 user와 구분하기 위해 person으로(context엔 user라는 이름으로 넘기지 않는 것을 권장)
    context = {
        'person': person,
    }
    return render(request, 'accounts/profile.html', context)
```

### 프로필 페이지의 세부 내용 작성

```html
  <h1>{{ person.username }}님의 프로필</h1>

  <h2>{{ person.username }} 작성한 게시글</h2>
  {% for article in person.article_set.all %}
    <div>{{ article.title }}</div>
  {% endfor %}
  <hr>

  <h2>{{ person.username }} 작성한 댓글</h2>
  {% for comment in person.comment_set.all %}
    <div>{{ comment.content }}</div>
  {% endfor %}
  <hr>

  <h2>{{ person.username }} 좋아요 한 게시글</h2>
  {% for article in person.like_articles.all %}
    <div>{{ article.title }}</div>
  {% endfor %}
  <hr>
```

### index 페이지에서 프로필로 이동할 수 있도록 링크 추가

- 자신의 프로필로 갈 수 있도록 if 조건을 걸어준다.

```html
  {% if request.user.is_authenticated  %}
    <a href="{% url "accounts:profile" user.username %}">내 프로필</a>
```

- 다른 유저의 프로필 페이지로도 이동할 수 있도록 해당 유저 명에 프로필 링크를 준다

```html
  {% for article in articles %}
    <div>
      <p>
        작성자 : 
        <a href="{% url "accounts:profile" article.user.username %}">{{ article.user }}</a>
      </p>
```

## 모델 관계 설정

### User(M) - User(N)

- 팔로우는 유저와 유저와의 관계를 나타냄
    - 회원은 여러 명의 회원을 팔로우 하거나 하지 않을 수도 있음
    - 팔로워를 여럿 가지거나 아예 없을 수도 있다

### 팔로우 모델 관계 설정

**커스텀한 User 모델 클래스에 ManyToManyField를 사용하여 팔로우 필드 추가**

- User 모델과 관계를 맺는 것이기 때문에 `settings.AUTH_USER_MODEL` 을 사용해도 되지만,,
- 자기 자신과의 관계이기 때문에 `"self"` 로 표현 가능
- 팔로우 기능은 단방향 관계이기 때문에 `symmetrical 속성 False` 설정
- 참조 필드는 followings 필드(내가 팔로우 하는 사람들을 의미)
    - 그렇기 때문에  역참조명 ‘followers’로 변경

```python
# accounts/models.py

class User(AbstractUser):
		followings = models.ManyToManyField('self', symmetrical=False, related_name='followers')
```

## 기능 구현

### 팔로우 기능을 위한 URL 추가

- 어느 사용자를 팔로우 하는지 사용자에 대한 정보를 variable routing을 활용하여 전달

```python
from django.urls import path
from . import views

app_name = 'accounts'
urlpatterns = [
    path('login/', views.login, name='login'),
    path('logout/', views.logout, name='logout'),
    path('signup/', views.signup, name='signup'),
    path('delete/', views.delete, name='delete'),
    path('update/', views.update, name='update'),
    path('password/', views.password, name='password'),
    # <username> 이라고해도됨 str은 기본값.
    # 문자열로 시작하는 variable routing 은 사용시 주의해야함
    # 왜냐면 이걸 맨위에 넣으면 다른 밑에 있는 정상 경로들을 안찾을 수 도 있기 때문에,,,
    path('profile/<str:username>', views.profile, name='profile'),
    path('<int:user_pk>/follow/', views.follow, name='follow'),
]
```

### View함수 기능 구현

- 중개 테이블에 내 정보가 있으면 제거 : 팔로우 해제
- 중개 테이블에 내 정보가 없으면 추가 : 팔로우 진행

```python
def follow(request, user_pk):
    User = get_user_model()
    you = User.objects.get(pk=user_pk)
    me = request.user

    # 팔로우를 해야하는 지/ 언팔로우를 해야하는 지
    # 내가 상대방의 팔로워 목록에 없는지 있는지
    if me != you:
        if me in you.followers.all():
            you.followers.remove(me)
            # 또는 me.followings.remove(you)
        else:
            you.followers.add(me)
            # me.followings.add(you)
    return redirect('accounts:profile', you.username)
```

### 프로필 페이지에서 팔로우 기능을 추가

- 팔로우와 팔로잉이 몇 명 있는지 DTL을 사용하여 출력

```html
  <div>
    팔로워 : {{ person.follewrs.all|length }} / 팔로우 : {{ person.followings.all|length }}
  </div>
```

- 프로필 페이지의 유저(person)가 로그인한 사용자(request.user)의 페이지인 경우 팔로우 버튼 숨김
- 팔로우 여부에 따라 버튼의 텍스트를 다르게 출력

```html
  {% if request.user != person %}
  <form action="{% url "accounts:follow" person.pk %}" method="POST">
    {% csrf_token %}
    {% if request.user in person.followers.all %}
    <input type='submit' value='언팔로우'>
    {% else %}
    <input type='submit' value='팔로우'>
    {% endif %}
  </form>
  {% endif %}
```

## Fixtures

- 장고 개발 시 데이터 베이스 초기, 공유를 위해 사용되는 파일 형식

### Fixtures 사용 목적

- 초기 데이터 세팅
    - 웹 서비스가 처음 시작될 때 필요한 기본 데이터를 미리 세팅할 수 있음
- 테스트 샘플 데이터 준비
    - 테스트할 때, 항상 동일하고 예측 가능한 데이터 환경을 구축하여 테스트의 신뢰성과 반복 가능성을 높이는 데 활용
- 협업 시 동일한 데이터 환경 맞추기
    - 팀원들이 각자의 개발 환경을 설정할 때, 모두 동일한 초기 데이터나 특정 테스트 데이터 셋을 쉽게 공유하고 적용
    - 개발 환경 간의 일관성 유지와 협업 효율을 높이는 데 도움을 줌

### 초기 데이터의 필요성

- 협업하는 유저 A, B가 있다고 생각 했을 때
    1. A가 먼저 작업 후 원격 저장소에 PUSH
        - DB는 업로드하지 않기 때문에 데이터도 업로드 X
    - B가 원격 저장소에서 A가 PUSH한 프로젝트를 Pull
        - 결과적으로 B는 DB가 없는 프로젝트를 받게 됨
- 이 때 장고에서는 **fixtures**를 사용해 초기 데이터 제공

### fixtures 관련 명령어

- `dumpdata`
    - 데이터베이스에서 데이터를 내보낼 때 사용하는 명령어
    - 주로 JSON 형태로 추출
    - 특정 테이블의 데이터만 추출도 가능
- `loaddata`
    - 데이터베이스에 데이터를 불러올 때 사용하는 명령어
    - 내보내기 형태로 저장된 JSON을 읽어와서 데이터베이스에 저장함

### dumpdata

```bash
python manage.py dumpdata [앱이름.모델이름] [옵션] > 추출파일명.json
```

- 앱이름만 지정
    - 해당 앱의 모든 모델에 대한 데이터를 추출
- 앱이름.모델이름 지정
    - 특정 모델의 데이터를 추출
- 앱 혹은 모델명을 지정하지 않은 경우
    - 프로젝트 전체의 모델 데이터를 추출

```bash
python manage.py dumpdata --indent 4 articles.article > articles.json
```

- articles 앱의 Article 모델 데이터를 추출
    - `--indent 4` 는 들여쓰기를 4칸을 한다는 옵션
- 명령어 실행 후 articles.json 파일이 생성됨
- 이게 Article 모델의 모든 데이터임
- Fixtures 파일명은 자유롭게 작성 가능.

### loaddata

- Fixtures 파일의 기본 경로에 있는 파일을 DB에 반영

```bash
python manage.py loaddata 파일경로
```

- Fixtures 파일의 기본 경로
    - app_name/fixtures/
- 장고는 설치된 모든 app의 디렉토리에서 fixtures 폴더 이후의 경로로 fixtures 파일을 찾아 load 진행

```bash
python manage.py loaddata articles.json users.json comments.json
```

- 한번에 작성하면 장고가 우선 순위가 높은 파일부터 불러와서 순서는 상관없음
- loaddata를 실행하기 전에 해당 모델에 대한 마이그레이션이 완료되어 있어야 함
- 같은 PK를 가진 데이터가 이미 있으면 중복 에러가 발생할 수 있음
    - 이 경우 기존 데이터를 지우거나, 새로운 Fixture 파일을 사용해야 함

---

## Improve query

같은 결과를 얻기 위해 DB 측에 보내는 query 개수를 점차 줄여 조회하기 

- N+1 Problem을 해결할 수 있음

### N + 1 Problem

1개의 쿼리로 데이터를 가져왔더라도 관련 데이터를 추가로 가져오기 위해 추가 쿼리가 N개 더 실행되는 상황 

- ORM에서 관련 객체를 반복적으로 접근할 때 과도한 쿼리가 발생하는 현상
- 초기 1번 쿼리로 기본 데이터를 조회한 뒤, 각 객체의 연결된 데이터를 조회하며 N번의 추가 쿼리가 실행됨
- 이로 인해 총 N+1개의 쿼리가 발생하고, 데이터가 많을 수록 성능 저하, DB 부하가 심해질 수 있다

### `annotate`

- SQL의 GROUP BY를 사용
    - 각 행 별로 계산된 필드를 추가함
- 쿼리셋의 각 객체에 계산된 필드를 추가
    - 기존 필드에 새로운 필드를 추가하여 계산된 값을 넣어 반환
- 집계 함수(Count, Sum, Avg, Max, Min 등)와 함께 자주 사용됨

```bash
Book.objects.annotate(num_authors=Count('authors'))
```

- 의미
    - 결과 객체에 ‘num_authors’라는 새로운 필드를 추가
    - 이 필드는 각 책과 연관된 저자의 수를 계산
- 결과
    - 결과에는 기존 필드와 함께 ‘num_authors’필드를 가지게 됨
    - book.num_authors로 해당 책의 저자 수에 접근할 수 있게 됨

**BEFORE**

```html
{{ article.comment_set.count }}
```

**AFTER**

```bash
Article.objects.annotate(comment_count=Counts('comment')).order_by('-pk')
```

```html
{{ article.comment_count }}
```

- 게시글을 조회하면서 **댓글 개수까지 한번에 조회**해서 가져오기

### `select_related`

- FK 또는 OneToOne 관계에서 사용되는 장고 ORM 메서드
- 내부적으로 INNER JOIN 사용해서 관련 객체를 한 번에 불러옴

```bash
Book.objects.select_related('publisher')
```

- 의미
    - Book 모델과 연관된 Publisher 모델의 데이터를 함께 가져옴
    - FK 관계인 ‘publisher’를 JOIN하여 단일 쿼리 만으로 데이터 조회
- 결과
    - Book 객체를 조회할 때 연관된 Publisher 정보도 함께 로드
    - book.publisher.name과 같은 접근을 추가적인 데이터베이스 쿼리 없이 가능

**BEFORE**

```html
{% for article in articles %}
		<h3>작성자 : {{ article.user.username }}</h3>
{% endfor %}
```

**AFTER**

```bash
	Article.objects.select_related('user').order_by('-pk')
```

- 게시글을 조회하면서 **유저 정보까지 한번에 조회**해서 가져오기

### `prefetch_related`

- SQL이 아닌 Python 을 사용한 JOIN을 진행
    - 관련 객체들을 미리 가져와 메모리에 저장하여 성능 향상
- M:N 또는 N:1 역참조 관계에서 사용
    - ManyToManyField나 역참조 관계에 대해 별도의 쿼리를 실행

```bash
Book.objects.prefetch_related('authors')
```

- 의미
    - Book과 Author는 ManyToMany관계로 가정
    - Book 모델과 연관된 모든 Author 모델의 데이터를 미리 가져옴
    - 장고가 별도의 쿼리로 Author 데이터를 가져와 관계를 설정
- 결과
    - Book 객체들을 조회한 후, 연관된 모든 Author 정보가 미리 로드 됨
    - `for author in book.authors.all()` 과 같은 반복이 추가적인 데이터베이스 쿼리 없이 실행됨

**BEFORE**

```html
{% for comment in article.comment_set.all %}	
	<p>{{ comment.content }}</p>
{% endfor %}
```

**AFTER**

```python
articles = Article.objects.prefetch_related('comment_set').order_by('-pk')
```

### select_related & prefetch_related

- 문제 원인
    - 게시글 + 각 게시글의 댓글 목록 + 댓글의 작성자를 단계적으로 평가
    - 게시글 목록을 가져올 때 해당 게시글의 댓글 목록을 가져오기 위해 데이터베이스에 쿼리 요청
    - 이 때 댓글의 작성자를 확인하기 이ㅜ해 댓글마다 사용자 정보도 데이터베이스로 쿼리 요청
    
    ```html
    {% for article in articles %}
    	<p>제목 : {{ article.title }}</p>
    	<p>댓글 목록</p>
    	{% for comment in article.comment_set.all %}
    		<p>{{ comment.user.username }} : {{ comment.content }}</p>
    	{% endfor %}
    {% endfor %}
    ```
    

- 문제 해결 1단계
    - prefetch_related를 활용하여 게시글 조회할 때 같이 참조된 댓글 까지 조회하도록 수정
    
    ```python
    def index_4(request):
    		articles = Article.objects.prefetch_related('comment_set').order_by('-pk')
    		
    		context = {
    				'articles': articles,
    		}
    		return render(request, 'articles/index_4.html', context)
    ```
    
- 문제 해결 2단계
    - 댓글 정보를 요청할 때 select_related를 활용하여 댓글 작성자 정보를 JOIN 하여 가져온 다음 Prefetch 함수를 이용하여 게시글 정보와 같이 요청해서 가져오도록 수정
    
    ```python
    from django.db.models import Prefetch
    def index_4(request):
    		articles = Article.objects.prefetch_related(
    				Prefetch('comment_set', queryset=Comment.objects.select_related('user'))
    		).order_by('-pk')
    		context = {
    				'articles': articles,
    		}
    		return render(request, 'articles/index_4.html', context) 
    ```