### **1. 게시글과 사용자 모델 관계**

- **Many-to-One 관계**:
    - 사용자와 게시글은 1:N 관계임. 한 명의 사용자는 여러 개의 게시글을 작성할 수 있고, 게시글은 하나의 사용자만 가짐.
    - 게시글 테이블에서 사용자 정보를 외래키로 참조함.
- **외래키 추가**:
    - 게시글 모델에 `ForeignKey`를 사용해서 사용자를 참조하는 컬럼을 추가함. `on_delete` 옵션을 `CASCADE`로 설정해서 사용자가 삭제되면 해당 사용자가 작성한 게시글도 삭제됨.
    - 이 때 `settings.AUTH_USER_MODEL`을 사용하여 사용자 모델을 지정하는 이유는 **Django 프로젝트에서 커스텀 사용자 모델을 사용하기 위한 권장 방식**이기 때문임. 이를 통해 프로젝트의 사용자 모델을 추후 변경해도 코드 수정 없이 적용할 수 있음.
- **사용자 정보 저장**:
    - 게시글 작성 시 `request.user`를 통해 로그인된 사용자의 정보를 자동으로 저장함. 이렇게 해서 게시글을 작성한 사용자를 추적할 수 있음.

```python
from django.db import models
from django.conf import settings

class Article(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)  # 사용자 정보 외래키
    title = models.CharField(max_length=10)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

class Comment(models.Model):
    article = models.ForeignKey(Article, on_delete=models.CASCADE)
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)  # 댓글 작성자 외래키
    content = models.CharField(max_length=200)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
```

---

### **2. 게시글 작성 시 유저 정보 포함**

- **게시글 작성 시 유저 정보**:
    - 게시글을 작성하려면 사용자가 로그인한 상태여야 하므로 `request.user` 객체를 사용해서 유저 정보를 자동으로 가져옴.
    - `request.user`는 로그인된 사용자의 정보로, 게시글 모델에 해당 사용자를 외래키로 연결함.
- **폼 처리**:
    - 게시글 작성 폼에서 유저 정보는 숨기고 서버에서 자동으로 처리하도록 함. 사용자는 폼에서 유저 정보가 보이지 않지만, 서버에서 `request.user`를 통해 해당 정보를 처리함.

```python
def article_create(request):
    form = ArticleForm(request.POST)
    if form.is_valid():
        article = form.save(commit=False)
        article.user = request.user  # 로그인된 사용자 정보로 설정
        article.save()
        return redirect('articles:list')
    return render(request, 'articles/create.html', {'form': form})
```

---

### **3. 댓글과 사용자 관계**

- **댓글 모델**:
    - 댓글은 1:N 관계로 게시글에 연결됨. 하나의 게시글에는 여러 개의 댓글이 달릴 수 있음.
    - 댓글 모델에서도 사용자 정보를 외래키로 추가함. `request.user`를 사용하여 댓글 작성자를 자동으로 연결함.
- **댓글 작성**:
    - 댓글을 작성할 때, 댓글은 `ForeignKey`로 연결된 게시글에 종속됨. 작성자는 `request.user`로 자동 설정됨.

```python
def comment_create(request, pk):
    article = Article.objects.get(pk=pk)
    form = CommentForm(request.POST)
    if form.is_valid():
        comment = form.save(commit=False)
        comment.article = article
        comment.user = request.user  # 로그인된 사용자 정보로 설정
        comment.save()
        return redirect('articles:detail', article.pk)
    return render(request, 'articles/detail.html', {'article': article, 'form': form})
```

---

### **4. 작성자 정보 확인 및 삭제 권한**

- **작성자 확인**:
    - 수정 및 삭제 기능은 자신이 작성한 게시글이나 댓글에 대해서만 허용됨. 다른 사용자가 작성한 게시글이나 댓글을 수정하거나 삭제하려고 할 때, `if request.user == article.user` 조건을 확인하여 이를 차단함.
- **수정 및 삭제 시 권한 확인**:
    - 사용자가 수정하거나 삭제하려면 작성자만 가능함. 이를 통해 다른 사용자가 실수로 수정할 수 없도록 보안이 강화됨.

```python
def comment_delete(request, article_pk, comment_pk):
    comment = Comment.objects.get(pk=comment_pk)
    if request.user == comment.user:  # 댓글 작성자가 맞는지 확인
        comment.delete()
    return redirect('articles:detail', article_pk)
```

```html
{% if request.user == article.user %}
    <a href="{% url 'articles:update' article.pk %}">수정하기</a><br>
    <form action="{% url 'articles:delete' article.pk %}" method="POST">
        {% csrf_token %}
        <input type="submit" value="삭제하기">
    </form>
{% endif %}
```

---

### **5. View decorators**

- view함수의 동작을 수정하거나 추가 기능을 제공하는 데 사용되는 Python 데코레이터
- 종류
    - Allowed HTTP methods
        - 뷰가 허용하는 HTTP 요청 방식(GET, POST)을 제한
    - Conditional view processing
        - 클라이언트가 보낸 조건을 확인한 후, 조건에 따른 응답 처리
    - GZip compression
        - 서버에서 응답 데이터를 압축해서 전송

### Allowed HTTP methods

특정 HTTP method로만 View 함수에 접근할 수 있도록 제한하는 데코레이터 

- require_http_methods([”METHOD1”, ”METHOD2”, …])
    - 지정된 HTTP method만 허용
- require_safe()
    - GET과 HEAD method만 허용
- require_POST()
    - POST method만 허용

```python
from django.views.decorators.http import require_http_methods

@require_http_methods(['GET', 'POST'])
def func(request):
		pass
```