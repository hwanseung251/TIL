## **후위 표기법(Postfix Notation)**

**중위 표기법(Infix Notation)**

- 연산자를 피연산자의 가운데 표기하는 방법
- `A + B`, `(A + B) * C` 등

**후위 표기법(Postfix Notation)**

- 연산자를 피연산자 뒤에 표기하는 방법
- `AB+`, `AB+C*` 등

### 후위 표기법을 배우는 이유

우리가 사용하는 `(3 + 5) * 2`와 같은 **중위 표기법**은 사람에게는 익숙하지만, 컴퓨터에게는 매우 모호하고 까다로운 식

컴퓨터는 이 식을 보면 아래와 같은 수많은 질문을 던져야 함

- "괄호가 있네? 괄호 안을 먼저 계산해야겠다."
- "더하기(`+`)와 곱하기(`*`)가 있네? 곱하기를 먼저 해야 하나?" (연산자 우선순위)

컴퓨터는 복잡한 규칙을 따르기보다, **정해진 순서대로 차근차근 계산**하는 것을 가장 잘함

**후위 표기법**은 바로 이 컴퓨터의 특성에 최적화된 방식

```
35+2*
```

위와 같은 후위 표기법 식을 컴퓨터는 왼쪽부터 순서대로 읽기만 하면 됨

1. `3`? 숫자네. 일단 기억해두자. (스택에 push)
2. `5`? 숫자네. 이것도 기억해두자. (스택에 push)
3. `+`? 연산자네! 방금 기억한 숫자 두 개(`5`, `3`)를 꺼내서 더해야지. 
결과는 `8`이네. 기억해두자. (스택에 push)
4. `2`? 숫자네. 기억해두자. (스택에 push)
5. `*` ? 연산자네! 방금 기억한 숫자 두 개(`2`, `8`)를 꺼내서 곱해야지.
결과는 `16`이네. 기억해두자. (스택에 push)

이처럼 후위 표기법은 **괄호나 연산자 우선순위를 전혀 고민할 필요 없이**, 단순한 규칙(숫자는 넣고, 연산자는 꺼내서 계산)만으로 식을 처리할 수 있게 함

**결론적으로, 우리가 후위 표기법을 배우는 이유는 사람의 언어(중위 표기법)를 컴퓨터가 가장 효율적으로 계산할 수 있는 언어(후위 표기법)로 번역하는 방법을 이해하고, 이 과정에서 스택(Stack)이라는 자료구조의 활용법을 익히기 위함**

⇒ 스택을 활용하면, **중위 표기법을 후위 표기법으로 변환**하고, **후위 표기법 식을 계산**할 수 있음

## **1. `중위 표기법 → 후위 표기법` 변환 방법**

### **1.1 알고리즘 개요**

1. 중위 표현식을 입력 받으면서 시작
2. **피연산자**(숫자, 문자 등)는 바로 출력(후위 표기법 결과에 추가)
3. **왼쪽 괄호**(`(`)는 무조건 스택에 push.
4. **오른쪽 괄호**(`)`)는 **왼쪽 괄호를 만나기 전까지** 스택에서 pop하여 출력. 
    - 단, 왼쪽 괄호(`(`)도 pop하되 출력은 하지 않음.
5. **연산자**(`+, -, *, /, ^` 등)는 스택의 top의 요소(isp)와 본인(icp)의 **우선순위**를 비교하여
    - 스택 top의 연산자가 현재 연산자보다 우선순위가 높거나 같으면(`isp ≥ icp`) 스택에서 pop하여 출력.
    - 그렇지 않으면(본인 우선순위가 더 높다면) 스택에 push.
6. 모든 입력(중위 표기식)을 처리한 후, 스택에 남은 연산자를 모두 pop하여 출력.

### **1.2 연산자 우선순위**

- `isp` (In-Stack Precedence)
    - 스택 안에 있는 연산자의 우선순위
- `icp` (In-Coming Precedence)
    - 새로 들어오는(아직 스택에 push되지 않은) 연산자의 우선순위
    
    | 토큰 | isp | icp | 특징 |
    | --- | --- | --- | --- |
    | `(` | 0 | 4 | 스택 안에 있으면 우선순위를 가장 낮게, 
    **새로 들어오면(스택 밖) 가장 높게** |
    | `^` | 3 | 4 | 거듭제곱은 오른쪽 결합성을 고려해 icp를 더 높게 설정(옵션) |
    | `*` `/` | 2 | 2 |  |
    | `+` `-` | 1 | 1 |  |
    - `)` 는 특별 취급
        - 왼쪽 괄호 `‘(’`를 만나기 전까지 pop
    - 거듭제곱(`^`)은 오른쪽 결합성을 반영하기 위해, icp를 isp보다 **1 크게** 설정
        - 이미 스택 안에 `^`가 있어도, 같은 우선순위의 `^`가 들어오는 경우 pop하지 않고 push 함(오른쪽 결합성)

- 오른쪽 결합성이란?
    
    “**연산자가 연달아 나올 때, 오른쪽의 연산부터 먼저 계산**하는 규칙”
    
    - 거듭제곱(`^`)이 대표적인 오른쪽 결합성 연산자
    
    **오른쪽 결합성 예시**
    
    일반적인 사칙연산(`+, -, *, /`)은 왼쪽 결합성(Left-associativity)을 따름
    
    - **왼쪽 결합성:** `10 - 5 - 2`는 `(10 - 5) - 2`로 계산되어 `5 - 2 = 3`이 됨
    
    하지만 거듭제곱(`^`)은 오른쪽 결합성 규칙을 따르기 때문에 순서가 반대임
    
    - **오른쪽 결합성:** `2 ^ 3 ^ 2`는 `2 ^ (3 ^ 2)`로 계산되어 `2 ^ 9 = 512`가 됨
        - 만약 왼쪽 결합성으로 계산했다면 `(2 ^ 3) ^ 2`가 되어 `8 ^ 2 = 64`라는 다른 결과가 나옴
    
    **후위 표기법 변환에서의 오른쪽 결합성 처리**
    
    후위 표기법으로 변환할 때, 스택 안에 있는 연산자의 우선순위(`isp`)와 새로 들어오는 연산자의 우선순위(`icp`)를 비교
    
    - **일반 연산자(`+`, `*`)**
        - `isp >= icp`일 경우, 스택의 연산자를 먼저 pop합니다. (`A + B + C`는 `AB+C+`로 변환)
    - **거듭제곱(`^`)**
        - `icp`를 `isp`보다 1 크게 설정하면, 스택에 `^`가 있어도 새로운 `^`가 들어올 때 pop하지 않고 스택에 push 됩니다.
        - 이로써 `2 ^ 3 ^ 2`가 `2 3 2 ^ ^`로 변환되어 오른쪽 연산부터 처리될 수 있도록 논리적인 순서를 만들어 줍니다.

### **1.3 코드 구현 (중위 → 후위)**

1. 딕셔너리 활용

```python
def infix_to_postfix(expression):
    precedence = {
    '+': 1,
    '-': 1,
    '*': 2,
    '/': 2,
    }
		stack = []
		result = []
		
		for token in expression:
				# 1. 토큰이 피연산자일 경우
				if token.isalnum():
						result.append(token)
				# 2. 여는 괄호 '('인 경우
				elif token == '(':
						stack.append(token)
				# 3. 닫는 괄호 ')'인 경우
				elif token != ')':
						# stack.pop이 여는 괄호가 될때까지 모든 연산자를 pop하여 결과에 추가
						# (스택이 비어있지 않고, top이 여는 괄호가 아닌 동안 반복)
						while stack and stack[-1] != '(':
								result.append(stack.pop())
						# 반복이 끝나면 스택 top은 '('이므로, 이를 pop하여 버림
						stack.pop()	
				# 4. 연산자인 경우
				else:
						# stack top에 있는 연산자 우선순위(isp)와 현재 연산자 우선순위(icp) 비교
						# 스택이 비어있지 않고, top이 여는 괄호가 아니며,
						# isp 가 icp 보다 크거나 같으면 계속 pop
						while (
								stack
								and stack[-1] != '('
								and precedence.get(stack[-1], 0) >= precedence.get(token, 0)
						):
								result.append(stack.pop())
						# 위 조건을 만족하지 않으면 (자기(token)보다 우선순위가 낮은 연산자를 만나면)
						# 현재 연산자를 스택에 넣는다
						stack.append(token)
			
		# 5. 모든 토큰 처리가 끝난 후 스택에 남아있는 연산자 처리
		# stack이 빌때까지 pop
		while stack:
				# 스택의 모든 연산자를 pop하여 결과에 추가
				result.append(stack.pop())
		# 6. 결과 리스트에 모든 요소를 하나의 문자열로 변환
		return "".join(result)
		 
# 테스트
expr1 = '(A+B)*C'
expr2 = '(A+B)*(C-D)'
print(infix_to_postfix(expr1))  
print(infix_to_postfix(expr2))
```

## **2. 후위 표기법 수식 계산**

### **2.1 알고리즘 개요**

1. **후위 표기법 식**을 왼쪽부터 순회
2. **피연산자**(숫자 등)를 만나면 스택에 push
3. **연산자**를 만나면
    
    ```
    1. 스택에서 피연산자 두 개(또는 필요한 개수)를 pop하고, 
        1.1 먼저 꺼낸 피연산자는 오른쪽에 위치
    2. 해당 연산을 수행한 결과를 다시 스택에 push
    ```
    
4. 식이 끝나면, 스택에 하나 남은 값이 결과 값.

### **2.2 예시**

- 후위 표기법: `A B + C *`
- `A = 2, B = 3, C = 4` 라고 가정하면, (`2 3 + 4 *`)
    1. `A(2)` → push → `stack = [2]`
    2. `B(3)` → push → `stack = [2, 3]`
    3. `+` → pop 3, pop 2 → 2+3=5 → push(5) → `stack = [5]`
    4. `C(4)` → push → `stack = [5, 4]`
    5. `*` → pop 4, pop 5 → 5*4=20 → push(20) → `stack = [20]`
    6. 결과 = **20**

### **2.3  코드 구현 (후위 표기법 계산)**

- 후위 표기법으로 주어진 식을 계산하여 숫자 결과 반환
    
    ```python
    def evaluate_postfix(expression):
    		stack = []
    		
    		# 후위표기법 수식을 왼쪽부터 순회
    		for token in expression:
    				# 1. 토큰이 숫자인 경우
    				if token.isdigit():
    						# 스택에 push
    						stack.append(int(token))
    				# 2. 토큰이 연산자인 경우
    				else:
    						# 스택에서 피연산자 2개를 pop
    						# (중요) 먼저 꺼낸 것이 연산의 오른쪽에 위치함
    						right = stack.pop()  # 두번째 피연산자
    						left = stack.pop()  # 첫번째 피연산자
    						
    						# 토큰에 따라 적절한 연산을 수행
    						if token == '+':
    								result = left + right
    						elif token == '-':
    								result = left - right
    						elif token == '*':
    								result = left * right
    						elif token == '/':
    								# 나누기의 경우 0으로 나ㅣ누는 상황을 고려할 수도 있음(여기서는 생략)
    								result = left / right
    						elif token == '^':
    								result = left**right
    						else:
    								# 정의되지 않은 연산자가 들어올 경우 처리
    								raise ValueError('잘못된 연산자입니다')
    								
    						# 연산 결과 result를 다시 스택에 push
    						stack.append(result)
    						
    		# 모든 연산이 끝난 후, 스택에 마지막으로 남은 값 하나가 최종 결과
    		return stack.pop()		
    						
    							
    ```
    

---

# 백트래킹

- 후보해를 구성해 나가다가, 더 이상 해가 될 수 없다고 판단되면 되돌아가서(backtrack) 다른 경로를 시도하는 방법
- 문제 해결을 위한 탐색 알고리즘의 하나
- 가능성이 없는 경로는 더 이상 탐색하지 않고 되돌아가며 해결책을 찾는 방식
- 최적화 문제(optimization)와 결정 문제(decision)에 적용
- 적용 예
    - N-Queens
    - 미로 찾기
    - 순열/조합 생성
    - 부분집합 탐색
    - 스도쿠 풀이 등

**Backtracking과 DFS와의 차이**

- Prunning(가지치기) 유무
    - Backtracking은 어떤 node에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않고 시도를 줄임
- 조기 경로 차단
    - DFS는 모든 경로를 추적, Backtracking은 불필요한 경로를 조기에 차단
- 경우의 수가 많은 경우
    - N!인 경우의 수를 가진 문제에 대해 DFS를 가하면 처리가 불가능함
    - Backtracking을 적용하면 일반적으로 경우의 수가 줄어들지만, 최악의 경우 지수함수 시간을 요하므로 처리가 불가능

**Backtracking 진행 절차**

1. 상태 공간 트리의 DFS 실시
2. 각 node가 유망한가 점검
3. 만일 그 node가 유망하지 않으면, 해당 node의 부모 node로 돌아감
4. 돌아간 node에서 검색을 계속함