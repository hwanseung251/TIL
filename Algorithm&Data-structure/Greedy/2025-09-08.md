# 부분 집합(powerset)

어떤 집합의 공집합과 자기 자신을 포함한 모든 부분

**집합에 포함된 원소들을 선택하는 것**

## 구현 방법

1. 완전탐색
    - 재귀호출을 이용한 완전탐색으로, 부분 집합을 구할 수 있음
    - 실전 보다는 완전 탐색 학습용으로 추천하는 방법
2. Binary Counting
    - 2진수 & 비트연산을 이용하여, 부분 집합을 구할 수 있음
    - 모든 부분 집합이 필요할 때 사용하는 추천 방법

### 완전 탐색(재귀 호출)

```python

# Branch : 2개
# Level : 3개

arr = ['O', 'X']
path = []

def run(lev)
		if lev == 3:
				print(path)
				return
		
		for i in range(2):
				path.append(arr[i])
				run(lev + 1)
				path.pop()
				
run(0)
```

### Binary Counting

- ex) 집합 {’A’, ‘B’, ‘C’} 에서 110이면 {’B’, ‘C’}를 001이면 {’A’}를 나타냄
- $2^n$을 `1<<n` 을 이용해 빠르게 구할 수 있다

```python
## 방법 1
arr = ['A', 'B', 'C']
n = len(arr)

for i in range(1 << n):
		for j in range(n):
				if i & (1 << j):
						print(arr[idx], end= " ")
		print()
```

```python
## 방법 2

arr = ['A', 'B', 'C']
n = len(arr)

def get_sub(tar):
		for i in range(n):
				# 0x1은 16진수로의 1임.
				# 1이라고 해도 되지만, 비트 연산임을 명시해주는 암묵적인 규칙.
				if tar & 0x1:
						print(arr[i], end='')
				tar >>= 1

# 6은 진수로 표현했을때 110이므로 마지막 한 자리가 1인지 0인지 검사함			
get_sub(6)

# get_sub(0) ~ get_sub(7)까지 호출하여 모든 부분 집합을 출력
for tar in range(1 << n):
		print('{', end='')
		get_sub(tar)
		print('}')
```

# 조합

서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것

| 유형 | 선택 방식 | 재귀 호출 시 고려하는 것 | 설명 |
| --- | --- | --- | --- |
| **순열 (Permutation)** | 순서를 고려 | - **아직 사용하지 않은 원소**를 하나 선택- 선택한 원소는 `visited=True` 표시 | 현재 나를 선택하면, 나를 제외한 **모든 남은 원소** 중에서 다음을 선택 |
| **조합 (Combination)** | 순서 상관 없음 | - 현재 나를 **선택했으면 → 다음 인덱스(i+1)** 부터 고려- 현재 나를 **선택 안 했으면 → 다음 인덱스(i+1)** 부터 고려 | 즉, "현재 원소를 뽑을지/안 뽑을지" 결정하고, 항상 **앞으로만** 나아감 |
| **부분집합 (Subset, Power set)** | 포함/비포함 분기 | - 현재 나를 **포함했을 때** 재귀- 현재 나를 **포함하지 않았을 때** 재귀 | 모든 원소에 대해 "포함 / 미포함" 두 가지 선택지를 끝까지 탐색 |

# 탐욕 알고리즘

결정이 필요할 때, 현재 기준으로 가장 좋아 보이는 선택지로 결정하여 답을 도출하는 알고리즘

## 대표적인 문제 해결 기법

1. 완전 탐색
    - 답이 될 수 있는 모든 경우를 시도해보는 알고리즘
2. Greedy
    - 결정이 필요할 때 가장 좋아 보이는 선택지로 결정하는 알고리즘
3. DP
    - 현재에서 가장 좋아 보이는 것을 선택하는 것이 아닌, 과거의 데이터를 이용하여 현재의 데이터를 만들어내는 문제해결 기법
4. 분할 정복
    - 큰 문제를 작은 문제로 나누어 해결하는 문제해결 기법

### 도대체 어떤 문제가 Greedy?

**Greedy vs DP**

| **항목** | **Greedy 알고리즘** | **Dynamic Programming (DP)** |
| --- | --- | --- |
| **문제 해결 방식** | 현재 시점에서 가장 최적인 선택을 반복하여 전체 문제를 해결 | 문제를 작은 부분 문제로 나누고, 각 부분 문제를 해결한 후 이를 결합하여 최적해를 구함 |
| **주요 특징** | 국소적인 최적 선택을 통해 최적해를 구함 | 최적 부분 구조와 중복되는 부분 문제를 활용하여 전체 최적해를 구함 |
| **시간 복잡도** | 보통 **$O(n)$** (선택에 따라 다를 수 있음) | 보통 $O(n^2)$ 또는 더 복잡할 수 있음 (부분 문제 저장에 따른 메모리 사용) |
| **메모리 사용** | 상대적으로 적음 (추가적인 테이블이나 배열 사용 없음) | 비교적 많음 (부분 문제 결과를 저장하는 테이블 또는 배열 사용) |
| **문제의 특성** | 최적 부분 구조와 그리디 선택이 최적해를 보장하는 문제 | 최적 부분 구조와 중복되는 부분 문제가 존재하는 문제 |
| **문제 해결 방식의 예시** | **활동 선택 문제**, **동전 거스름돈 문제** | **배낭 문제 (Knapsack)**, **최장 공통 부분 수열 (LCS)** |
| **정확성** | 항상 최적해를 보장하지 않음 | 항상 최적해를 보장함 |
| **적합한 문제 유형** | 선택이 반복적이며 각 선택이 독립적인 경우 | 중복되는 부분 문제와 최적 부분 구조가 있을 때 |
| **선택 과정** | 각 단계에서 가장 좋은 선택을 한다 (탐욕적 선택) | 각 단계에서 최적 부분 문제를 풀고, 그 해를 합쳐서 최적해를 구함 |
| **문제 해결의 예시** | **활동 선택 문제**: 종료 시간이 빠른 활동부터 선택 | **배낭 문제**: 여러 물건을 배낭에 담을 때 가방 용량을 초과하지 않도록 최적화 |
| **복잡도** | 상대적으로 낮음 (단일 선택 기반) | 상대적으로 높음 (부분 문제 저장 및 계산 필요) |

Greedy는 규칙성을 찾아야 한다. → 규칙을 못 찾거나, 항상 최적해를 보장하는 규칙이 없다면 못 품

### 현재 상황에 그냥 무조건 제일 좋은 거 고르면 안되나?

1. 탐욕적 선택 조건
    - 각 단계의 최적해 선택이 이 후 단계 선택에 영향을 주지 않아야 함
    - 즉, 각 단계 규칙이 변경되면 안된다
2. 최적 부분 구조
    - 각 단계의 최적해 선택을 합하면, 전체 문제의 해결책이 되어야 함
        
        → 증명을 통해 해결
        
        - 동전 문제 예시
            
            <aside>
            
            [명제] 가장 큰 동전부터 고르면 최소 동전 수가 나온다
            
            [간접 증명] 
            
            최적해보다 더 적은 동전으로 표현 가능하다 (가정)
            
            → N원을 더 작은 값의 동전으로 더 작은 수로 할 수 있다
            
            ⇒ 동전이 배수로 있기 때문에 안됨
            
            ⇒ 더 적은 값으로 나누면 무조건 더 큰 수가 나옴
            
            → 모순 발생
            
            ⇒ 원래 명제가 참 
            
            </aside>
            
3. 반례가 없는가?

# ✍️추가 학습

## Greedy 문제 단골손님 sort에 대한 정리

### `list.sort()`와 `sorted()`의 차이점

| **항목** | **`list.sort()`** | **`sorted()`** |
| --- | --- | --- |
| **반환값** | `None` (원본 리스트를 직접 변경) | 새로운 정렬된 리스트를 반환 |
| **사용 대상** | 리스트 객체만 사용 가능 | 리스트, 튜플, 문자열 등 모든 iterable 사용 가능 |
| **정렬 방식** | 원본 리스트가 직접 변경 | 원본 리스트는 변경되지 않으며, 새로운 리스트 반환 |
| **인-플레이스** | Yes (원본 리스트 자체를 변경) | No (새로운 리스트 반환) |
| **속도** | 더 빠름 (메모리 절약) | 메모리 사용이 더 많음 (새 리스트 생성) |
| **리스트 수정 여부** | 리스트를 직접 수정하여 정렬 | 리스트를 복사하여 정렬한 새로운 리스트를 반환 |
| **사용 예시** | `my_list.sort()` | `sorted(my_list)` |

### **`list.sort()`**

`list.sort()`는 **리스트 객체에만** 사용 가능하며, 원본 리스트를 직접 수정하여 정렬함. 반환값은 `None`이므로, 정렬된 리스트를 얻기 위해서는 원본 리스트를 그대로 사용해야 함.

### 예시:

```python
my_list = [3, 1, 4, 1, 5, 9, 2, 6, 5]
my_list.sort()  # my_list가 변경됨
print(my_list)  # [1, 1, 2, 3, 4, 5, 5, 6, 9]
```

---

# 심화 활용법

`list.sort()`는 다양한 방식으로 활용할 수 있습니다. 기본적인 정렬 외에도 커스터마이징된 정렬을 위해 `key`와 **`reverse`** 매개변수를 활용할 수 있습니다.

## 1. **`key` 매개변수 활용**

`key` 매개변수는 **정렬 기준을 지정**하는 함수입니다. 이 함수를 사용하면 각 원소를 비교할 때, 그 원소를 직접 비교하는 대신, 특정 조건에 맞게 변형된 값으로 비교하게 할 수 있습니다.

### 예시: 문자열 길이 기준으로 정렬

```python
words = ['apple', 'banana', 'cherry', 'date']
words.sort(key=len)  # 단어의 길이를 기준으로 정렬
print(words)  # ['date', 'apple', 'banana', 'cherry']
```

### 예시: 튜플의 두 번째 값 기준으로 정렬

```python
tuples = [(1, 'apple'), (3, 'banana'), (2, 'cherry')]
tuples.sort(key=lambda x: x[1])  # 두 번째 원소(문자열) 기준으로 정렬
print(tuples)  # [(1, 'apple'), (3, 'banana'), (2, 'cherry')]
```

## 2. **`reverse` 매개변수 활용**

`reverse=True`를 사용하면 정렬 결과를 내림차순으로 바꿀 수 있습니다. 기본적으로 `list.sort()`는 오름차순으로 정렬합니다.

### 예시: 내림차순 정렬

```python
numbers = [5, 3, 9, 1, 7]
numbers.sort(reverse=True)  # 내림차순으로 정렬
print(numbers)  # [9, 7, 5, 3, 1]
```

## 3. **복합 정렬**

`key`와 `reverse`를 함께 사용할 수 있습니다. 이를 통해 복합적인 정렬을 할 수 있습니다.

### 예시: 튜플의 두 번째 값을 기준으로 내림차순 정렬

```python
tuples = [(1, 'apple'), (3, 'banana'), (2, 'cherry')]
tuples.sort(key=lambda x: x[1], reverse=True)  # 두 번째 원소(문자열)를 기준으로 내림차순
print(tuples) # [(2, 'cherry'), (3, 'banana'), (1, 'apple')]
```

## 4. **다중 기준 정렬**

정렬 기준을 여러 개로 설정할 수 있습니다. `key` 함수에서 반환값이 튜플인 경우, 각 요소가 순차적으로 기준이 됩니다.

### 예시: 튜플의 첫 번째 값 기준으로 오름차순, 두 번째 값 기준으로 내림차순

```python
tuples = [(1, 'apple'), (3, 'banana'), (2, 'cherry')]
tuples.sort(key=lambda x: (x[0], -len(x[1])))  # 첫 번째 값 오름차순, 두 번째 값의 길이 내림차순
print(tuples)  # [(1, 'apple'), (2, 'cherry'), (3, 'banana')]
```

---

## 탐욕 알고리즘 문제 해결을 위한 4가지 Tip

### 1. 문제 유형 파악하기 - "최적화 문제인가?"

가장 먼저, 문제의 요구사항이 최적화 문제인지 확인하자.

- **키워드 확인**: 문제에서 `*"최소"*`, `*"최대"*`, `*"최소 횟수"*` , `*"최대한 많은"*` 과 같은 단어를 찾는 것이 첫 번째 신호이다. 이는 여러 가능한 답 중에서 가장 좋거나 나쁜 ‘최적의 해’를 하나만 찾으라는 의미이다.
- **되돌릴 필요가 없는가?**:
    - 스스로에게 "한 번 내린 선택을 나중에 다시 바꾸거나 되돌릴 필요 없이, 앞으로 나아가기만 해도 답이 나올까?" 라고 물어보기
    - 만약 그렇다고 느껴진다면 그리디 문제일 가능성이 높다.
    - 반대로 *“A를 선택했다가, 아니다 싶으면 B로 바꿔서 다시 시도해야 한다”* 라면, 이는 **백트래킹** 문제임.

---

### 2. 탐욕적 선택 기준(Greedy Choice) 찾기 - "무엇을 기준으로 정렬할까?"

그리디 문제임이 의심된다면, *"매 순간 어떤 기준으로 선택하는 것이 가장 이득일까?"* 를 찾아야 한다.

- **정렬 기준 찾기**: 문제의 핵심 가치를 나타내는 기준으로 데이터를 정렬하는 것이 핵심.
    - 종료 시간이 가장 빠른 순서 → *화물 도크(활동 선택 문제)*
    - 무게/가치가 가장 큰 순서 → *컨테이너 운반(배낭 문제 변형)*
    - 마감 시간이 임박한 순서 → *작업 스케줄링 문제*
    - 길이가 짧거나 긴 순서 등

> 즉, *“이 문제의 데이터들을 어떤 기준으로 줄 세워야, 맨 앞(또는 맨 뒤)부터 처리하는 게 항상 최선일까?”* 를 고민하는 것이 그리디 알고리즘 해결의 90%임
> 

---

### 3. 선택 증명해보기 - "이 선택에 후회는 없는가? (반례 찾기)"

나의 '탐욕적 선택'이 항상 올바른지 간단하게 검증하는 습관이 매우 중요함.

- **반례 찾아보기**:
    
    "지금 당장 가장 좋아 보이는 이 선택이, 나중에 더 큰 이득을 얻을 수 있는 기회를 막아버리지는 않을까?"를 생각해보자
    
- **방법**:
    
    작은 예시(N=3~4)를 직접 손으로 시뮬레이션해보며 반례 찾기.
    
- **반례가 존재한다면**: 그 문제는 **그리디 알고리즘으로 풀 수 없는 문제**.
    - 예: *요리사 문제* → 모든 경우의 수를 따져봐야 하는 전 탐색(백트래킹, DP) 문제

---

### 4. 코드 구현하기 - "정렬하고, 순회하고, 선택하기"

탐욕적 선택 기준을 찾았다면, 코드 구현은 보통 간단한 패턴을 따름.

1. 입력 데이터를 핵심 기준에 따라 정렬
2. `for` 또는 `while` 반복문으로 정렬된 데이터 순회
3. 현재 상태를 기준으로 선택할지 말지 결정
4. 선택했다면 정답과 상태 변수를 갱신하고 다음으로 진행

---

## [요약] 그리디 문제 해결 생각의 흐름

| 단계 | 질문 | 핵심 활동 | 예시 문제 |
| --- | --- | --- | --- |
| **1. 유형 파악** | 최소/최대 값을 찾는가?선택을 되돌릴 필요가 없는가? | 최적화 문제임을 인지하고 그리디 가능성 확인 | 컨테이너 운반, 화물 도크 |
| **2. 기준 찾기** | 무엇을 기준으로 정렬해야 매번 가장 이득일까? | 종료 시간, 무게, 가치 등 핵심 기준으로 정렬 | 화물 도크(종료 시간), 컨테이너 운반(무게/가치) |
| **3. 증명/검증** | 내 선택이 미래의 더 좋은 선택을 막지는 않는가? | 간단한 반례를 손으로 생각해보거나 그려보기 | 요리사 문제 (반례 존재 → 그리디 ❌) |
| **4. 구현** | 정렬 후, 어떻게 순회하며 선택을 누적할까? | `for` 또는 `while` 반복문으로 정렬된 데이터 처리 | 컨테이너 운반(큰 것부터 비교) |