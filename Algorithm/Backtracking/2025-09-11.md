### 백트래킹 개념

- 여러 가지 선택지(옵션)들이 존재하는 상황에서 한 가지를 선택함
- 선택이 이루어지면 새로운 선택지들의 집합이 생성됨샐
- 이런 선택을 반복하면서 최종 상태에 도달함
    - 올바른 선택을 계속하면 목표 상태(goal state)에 도달

### 백트래킹과 깊이 우선 탐색과의 차이

- 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임
- 이를 Pruning(가지치기)라고 함
- 깊이 우선 탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기에 차단
- 깊이 우선 탐색을 가하기에는 경우의 수가 너무나 많은 경우, 즉 N!(같은 열을 막으면) 가지의 경우의 수를 가진 문제에 대해 깊이 우선 탐색을 가하면 당연히 처리 불가능한 문제가 됨
- 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만, 역시 최악의 경우에는 여전히 지수 함수 시간을 요하므로 처리 불가능함

# N-Queens 문제

## 1. 문제 정의

- **목표**
    
    N×N 체스판에 N개의 퀸을 배치하되, **서로 공격할 수 없도록** 놓는 모든 경우를 구하는 문제.
    
- **제약 조건**
    - 같은 **행**에 2개 이상의 퀸 불가
    - 같은 **열**, **대각선**에도 2개 이상의 퀸 불가
- **특징**
    - 모든 가능한 배치를 전부 탐색하면 경우의 수는 $N^N$ (8-Queens는 **4,426,165,368개**)
    - 실제 해의 개수는 92개뿐 → **효율적 탐색**이 핵심

---

## 2. 백트래킹(Backtracking) 접근

백트래킹은 **상태 공간 트리(State-Space Tree)** 를 깊이 우선 탐색(DFS)하면서,

**유망하지 않은 노드(pruning)**를 조기 차단하여 탐색 공간을 줄이는 기법입니다.

### 알고리즘 절차

1. **DFS 탐색**으로 가능한 모든 퀸 배치를 시도
2. 매 단계마다 현재 위치가 **유망(promising)** 한지 검사 (`check()` 함수)
3. 유망하지 않으면 해당 노드에서 **백트래킹** → 부모 노드로 돌아가 다른 경로 탐색

> 즉, 가지치기(pruning) 를 통해 불필요한 탐색을 제거하여 시간복잡도를 줄임
> 

---

## 3. N-Queens 백트래킹 코드 예시

```python
N = 8
board = [-1] * N   # board[row] = col 위치에 퀸을 둠
count = 0

def is_promising(row, col):
    for prev_row in range(row):
        if board[prev_row] == col:  # 같은 열
            return False
        if abs(board[prev_row] - col) == abs(prev_row - row):  # 대각선
            return False
    return True

def n_queens(row):
    global count
    if row == N:
        count += 1
        return
    for col in range(N):
        if is_promising(row, col):
            board[row] = col
            n_queens(row + 1)
            board[row] = -1

n_queens(0)
print("해의 개수:", count)

########## 2차원 배열로 검사한다면
visitied = [[False] * N for _ in range(N)]

def is_promising(row, col):
		# 같은 열에 놓인적이 있나?
		for i in range(row):
				if visited[i][col]:
						return False 
		# 좌 대각선 검사(\)
		# 좌 대각선 위로는 행과 열이 모두 1씩 감소함을 활용
		i, j = row - 1, col - 1
		while i >= 0 and j >= 0:
				if visited[i][j]:
						return False
				i -= 1
				j -= 1
				
		# 우 대각선 검사(/)
		# 우 대각선 위로는 행은 1씩 감소하지만 열은 1씩 증가함을 활용
		i, j = row - 1, col + 1
		while i >= 0 and j < N:
				if visited[i][j]
						return False
				i -= 1
				j += 1	
				
		return True
```

---

## 4. `is_promising()` 함수 구현 방식 비교

| 구분 | 2차원 배열 검사 방식 | 1차원 배열(기울기 활용) 방식 |
| --- | --- | --- |
| **방법** | `visited[row][col]`, `visited_diag1`, `visited_diag2` 배열을 사용해 현재 위치가 안전한지 검사 | `board[row] = col` 형태로 1차원 배열에 열 정보만 저장하고, `abs(row1-row2) == abs(col1-col2)` 조건으로 대각선 검사 |
| **공간 복잡도** | O(N²) (체스판 전체 상태를 저장) | O(N) (열 정보만 저장) |
| **시간 복잡도** | 각 노드 검사 시 최대 O(N) (대각선 배열 포함) | 각 노드 검사 시 O(N) (단, 접근이 훨씬 빠름) |
| **장점** | 직관적, 시각적으로 이해하기 쉬움 | 메모리 효율적, 빠른 연산 가능 |
| **단점** | 메모리 낭비 큼, N이 커질수록 비효율적 | 기울기 조건 이해 필요 (처음 배우는 사람에게는 직관적이지 않을 수 있음) |
| **최적화** | ❌ 메모리 낭비 발생 | ✅ **가장 효율적** (공간 최적화 + 빠른 탐색) |

> 결론:
> 
> 
> 1차원 배열과 기울기 활용 방식이 **메모리 사용을 줄이고** 속도를 높이는 최적화된 방법입니다.
> 
> 대규모 N-Queens 문제(N>12)에서 성능 차이가 뚜렷해집니다.
> 

---

## 5. 핵심 정리

- N-Queens 문제는 **백트래킹 + 가지치기**로 효율적 탐색 가능
- `check()`는 **열, 우/좌 대각선**만 검사하면 충분
- **1차원 배열 + 기울기 활용 방식**이 최적화에 더 적합

---

# 트리

- 트리는 싸이클이 없는 무향 연결 그래프
    - 두 노드(정점) 사이에는 유일한 경로가 존재
    - 각 노드는 최대 하나의 부모 노드가 존재할 수 있음
    - 각 노드는 자식 노드가 없거나 하나 이상이 존재할 수 있음
- 비선형 구조
    - 원소들 간에 1:n 관계를 가지는 자료구조
    - 원소들 간에 계층관계를 가지는 계층형 자료구조

## 순회할때 그래프 저장 방식 vs 일차원리스트 저장 방식 비교

### 트리 저장 방식 ①: 그래프(노드+자식 정보 저장)

트리를 **노드 객체 or 인접 리스트**로 저장하는 방식.

예시 구조

```python
# 노드 객체 방식
class Node:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

# 트리 생성
root = Node(1,
            Node(2, Node(4), Node(5)),
            Node(3, None, Node(6)))
```

중위순회 코드

```python
def inorder(node):
    if node:
        inorder(node.left)        # 왼쪽 서브트리 방문
        print(node.value, end=' ')  # 현재 노드 방문
        inorder(node.right)       # 오른쪽 서브트리 방문

inorder(root)  # 출력: 4 2 5 1 3 6
```

- **특징**
    - 트리 구조 그대로 저장 (노드 간 연결 관계 보존)
    - 중위순회 시 **왼쪽 → 자기자신 → 오른쪽** 순서로 재귀 탐색
    - 트리 구조가 바뀌어도 순회 코드 동일 → 유연성 높음

### 트리 저장 방식 ②: 1차원 리스트 (배열) 저장 방식

트리를 **배열**에 저장하는 방식 (완전이진트리에 많이 사용)

- 루트 노드 = index 1 (혹은 0)
- 왼쪽 자식 = `index * 2`, 오른쪽 자식 = `index * 2 + 1`

예시 구조

```python
tree = [None, 1, 2, 3, 4, 5, None, 6]
# 인덱스:   0    1  2  3  4  5  6    7
#          (x)  (1)(2)(3)(4)(5)  (x)(6)
```

중위순회 코드

```python
def inorder(idx):
    if idx < len(tree) and tree[idx] is not None:
        inorder(idx * 2)          # 왼쪽 자식
        print(tree[idx], end=' ') # 현재 노드
        inorder(idx * 2 + 1)      # 오른쪽 자식

inorder(1)  # 출력: 4 2 5 1 3 6
```

- **특징**
    - 인덱스로 부모-자식 관계 계산 (추가 포인터 필요 없음)
    - 완전이진트리에 적합 → 힙(Heap) 같은 자료구조에서 많이 사용
    - 노드가 듬성듬성 있으면 배열 공간 낭비 발생 (스파스 트리 비효율적)

## 이진탐색트리의 성능

- 탐색/ 삽입/ 삭제 시간은 트리의 높이만큼 시간이 걸림
    - O(h)
- 평균의 경우(이진 트리가 균형적으로 생성되어 있는 경우)
    - O(log n)
- 최악의 경우(한쪽으로 치우친 경사 이진트리의 경우)
    - O(n) : 순차 탐색과 시간 복잡도가 같음

## 힙트리의 성능

- 노드 추가/삭제가 잦은 경우 쓰임
- 노드 추가/삭제 시간복잡도
    - O(log n)
- 최댓값/최솟값 시간복잡도
    - O(1)
- 힙정렬 시간복잡도 (노드 삽입 연산 + N개의 노드 삭제 연산이 N 필요하므로)
    - O(n log n)