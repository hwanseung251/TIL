# 비트 연산

- **1 bit** : 0과 1을 표현하는 정보의 단위
- **1 Byte** : 8-bit를 묶어 1 Byte라고 함(메모리 주소가 부여되는 단위)
- 컴퓨터의 CPU 내부적으로 비트 연산을 사용하여 덧셈, 뺄셈, 곱셈 등을 계산함

### 파이썬에서 2진수, 16진수, 10진수 변환하여 출력하기

- 2진수는 숫자 0과 소문자 b → 0b를 접두사로 붙여 표현함
- 16진수는 숫자 0과 소문자 x → 0x를 접두사로 붙여 표현함

## XOR 와 NOT 연산자

- `^` : XOR 연산자, 둘 다 1 이거나 0인 경우는 0 이다.

```python
a = bin(0b1011 ^ 0b1101)
print(a) # 0b110
```

- **어떤 값이던 특정 수로 2회 XOR하면 원래 수로 돌아온다**
    - 7070 ^ 1004 = 6258
    - 6258 ^ 1004 = 7070

## 비트연산자

- Left Shift << : 특정 수 만큼 비트를 왼쪽으로 밀어냄
- Right Shift >> : 특정 수 만큼 비트를 오른쪽으로 밀어냄
    
    ```python
    print(bin(0b1101 << 2)) # 0b110100
    print(bin(0b1101 >> 2)) # 0b11
    ```
    

## 비트 연산 응용

1. `1<<n` : $2^n$ 의 값을 갖음
2. `i & (1<<n)` : i의 n번째 비트가 1인지 아닌지를 확인할 수 있음

## 부분집합 구하기

1. 원하는 부분집합의 원소의 수를 구한다
2. 1을 `<<` 연산자를 활용해 원소의 수 만큼 밀면 ⇒ **부분집합의 총 개수** 가 나온다.
3. 부분집합의 총 개수 만큼 포문을 돌면서 나오는 수를 부분집합의 번호로 가정한다
4. 부분집합의 번호를 `&`  연산자와 활용하면서 이진수로 활용한다.
    1. 이진수를 원소의 수만큼 포문을 돌며 1을 `<<` 연산자로 밀며 검사한다.
5. `&`  결과가 True일 때, 그 위치의 원소를 추가한다.

```python
def generate_subset(arr):
    arr_len = len(arr)

    for i in range(1 << arr_len):
        for j in range(arr_len):
            if i & (1 << j):
                print(arr[j], end=" ")
        print()
```

## 음수 표현 방법

- 컴퓨터는 음수를 `2의 보수` 로 관리함
- 보수란?
    - 1의 보수: 1111 → 0000
    - 2의 보수: 1의 보수 + 1, 즉 0001 이 됨
- 2의 보수를 취한 수를, 한번 더 2의 보수를 취하면 **원래의 값으로 돌아옴**

## bitwise NOT(complement) 연산자

- ~ 연산자 : 모든 비트를 반전시킴
- 만약 8-bit 일 때 ~(0001 1111) 이라면 값은 1110 0000이 됨

## Bitwise NOT 연산자를 파이썬에서 수행하기

- 파이썬에서는 `~`4 를 수행하면 -5가 출력됨

---

## 실수 소수점 출력 방법(f-string)

- `{t2:.2f}` : t2 값을 소수점 셋째자리에서 반올림하여 표현