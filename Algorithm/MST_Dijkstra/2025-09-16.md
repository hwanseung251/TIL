## 최소 신장 트리(MST)

- 그래프에서 최소 비용 문제를 해결할 때 사용한다
- 모든 정점을 연결하는 간선들 중에서 가중치의 합이 최소가 되는 트리를 찾는다

**간선에 가중치가 들어간 그래프**는 어떻게 저장할까

- 인접 행렬 :  1대신 가중치가 들어가고
- 인접 리스트 : 튜플 형태로 정점과 가중치를 함께 묶어 저장한다.
    - 값 변경이 필요 없다면 튜플로 쓰는 것이 효율적이다.

### MST 찾기

1. 프림 알고리즘 : BFS 처럼 접근하면서 작은 가중치만!
2. 크루스칼 알고리즘 : 작은 가중치 간선 부터!

### 1. Prim

가능한 정점과 가중치를 튜플에 묶어 저장한 뒤, 가중치가 가장 작은 것을 계속 선택하려면..?

우선순위 큐 → 힙을 사용하자

```python
import heapq

def prim(start_node):
		pq = [(0, start_node)] # 가중치를 기준으로 정렬하기 위해서 가중치를 앞에 저장
		MST = [0] * V # visited와 동일한 자료구조
		min_weight = 0
		
		while pq:
				weight, node = heapq.heappop(pq)
				
				# 이미 방문한 노드라면 continue
				if MST[node]:
						continue
						
				MST[node] = 1        # BFS처럼 큐에 넣을 때 방문처리를 하면 안됨!!
				min_weight += weight # 이미 방문한 노드가 아닐때 방문처리해야 최소로 갈 수 있음
														 				
				for next_node in range(V):
						# 갈 수 없으면 continue
						if graph[node][next_node] == 0:
								continue
							
						if MST[next_node]:
								continue
								
						heapq.heappush(pq, (graph[node][next_node], next_node))

V, E = map(int, input().split())
graph = [[0]*V for _ in range(V)]

for _ in range(E):
		start, end, weight = map(int, input().split())
		graph[start][end] = weight
		graph[end][start] = weight
		
result = prim(0) # 만약 출발 정점을 0이 아닌 다른 노드로 해도 최소비용은 항상 똑같다
                 # 하지만 그래프가 다르게 나올 수는 있음
print(f"최소 비용 = {result}")		

```

### 2. Kruskal

가중치 기준으로 간선 들을 “정렬”

사이클 발생 시 선택을 하지 않는다 → Union Find!!

```python
def find_set(x):
		if x != parents[x]:
				parents[x] = find_set(parents[x])
		return parents[x]

def union(x, y):
		rx = find_set(x)
		ry = rind_set(y)
		
		if rx == ry: # 이 경우는 사이클이 발생한 것임
				return
				
		# 일정한 규칙으로 병합하기 위함(더 작은수로)
		if rx < ry:
				parents[ry] = rx
		else:
				parents[rx] = ry
			
		
V, E = map(int, input().split())

edges = []
for _ in range(E):
		start, end, weight = map(int, input().split())
		edges.append((start, end, weight))
		
# 가중치 기준 오름차순 정렬(작은 것 부터 이므로)
edges.sort(key=lambda x: x[2])
		
cnt = 0 # 현재까지 선택한 간선의 수
result = 0 # 가중치의 합

# make_set
parents = [i for i in range(V)]

# 가중치가 작은 간선부터 순서대로 선택하자
# 사이클이 발생하면 고르지 말자!
for u, v, w in edges:
		# 사이클이 아니라면 
		# 연결(같은 집합으로 만든다) -> why? : 최소 비용을 알고싶은거지 완성된 그래프 형태를 알고싶은게 아님
		if find_set(u) != find_set(vf): # find_set
				union(u, v) # union
				cnt += 1
				result += w
				
				# 언제까지??
				# V-1개를 선택해서 MST가 완성될 때 까지
				if cnt == V - 1:
						break
						
print(f"최소 비용 = {result}")
```

그렇다면 **프림**과 **크루스칼** 중에서 언제 무엇을 선택해야 될까?

<aside>
💡

둘의 큰 차이는 프림은 정점을 기준으로 크루스칼은 간선을 기준으로 선택한다

→ 간선이 많을 수록 무엇이 유리할까?를 생각해보자!

- 간선이 많을 수록 완전 그래프 일수록 프림이 유리함
</aside>

---

## 최단 경로

간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로

### 최단 경로의 종류

1. 하나의 시작 정점에서 끝 정점까지의 최단 경로

**다익스트라**

누적 비용이 작은 곳으로 가자

단점: 음의 가중치를 허용하지 않음 → 벨만 포드 알고리즘으로 해결

1. 모든 정점들에 대한 최단 경로

**플로이드**

## 다익스트라

누적 거리 리스트가 필요함 : INF로 가득찬 dist 배열!

누적 거리가 짧은 경로를 먼저 꺼냄(pq)

값은 언제 저장하는게 좋을까? 큐에 넣을 때? 뺄 때?

- 만약 한 노드를  가기 위한 여러 경로가 있다고 가정하면
- 지금의 비용보다 더 높은 비용의 경로가 계속 들어오게 된다면? → 비효율적임
- 따라서 큐에 넣으면서 값을 저장해주는 것이 효율적이다

**아래 코드로 현재, 그리고 다음 노드를 큐에 넣을 때 두 번 검사하는 이유** 

> # 이미 더 작은 값으로 온적이 있으면 버림
if distance[node] < current_dist:
	continue
> 

이 작업은 오래전에 들어온 현재 보다 높은 가중치(예전엔 가장 낮은거였음)의 노드가 들어올 때 이를 계산하지 않도록 해준다

> # 이미 크거나 같은 가중치로 온 적이 있다면 continue
if distance [next_node] <= new_dist :
	continue
> 

이 작업은 개선이 되는 경우만 추가해 줌으로써 불필요한 계산을 줄이도록 해준다.

```python
import heapq

def dijkstra(start_node):
		pq = [(0, start_node)] 
		distance = [INF] * V
		distance[start_node] = 0
		
		while pq:
				current_dist, node = heapq.heappop(pq)
				
				# 이미 더 작은 값으로 온적이 있으면 버림
				if distance[node] < current_dist:
						continue
					
				for next_dist, next_node in graph[node]:
						# 다음 노드로 가기 위한 누적 거리
						# 누적 거리 = 현재까지의 거리(w) + 다음 거리(next_w)
						new_dist = current_dist + next_dist
						
						# 이미 크거나 같은 가중치로 온 적이 있다면 continue
						if distance[next_node] <= new_dist :
								continue
						distance[next_node] = new_dist 
						heapq.heappush(pq, (new_dist , next_node)))
		return distance 
						
INF = float("inf")

V, E = map(int, input().split())
start_node = 0
graph = [[] for _ in range(V)] # 인접리스트로 구현 (물론 둘다 가등함)

for _ i range(E):
		start, end, weight = map(int, input().split())
		graph[start].append((weight, end)) # 주의 단방향이기때문이 이렇게만

# 출발지로 부터 최단거리		
result = dijkstra(0)
print(result)
```

## 정리

### MST와 다익스트라는 목적이 서로 다르다

MST는 트리 전체의 총 가중치 합을 최소화 하기 위함이고

다익스트라는 “경로 상의 최대 간선 가중치”를 최소화하는 것이다. 

→ 즉 MST의 모든 노드를 잇는 최소 경로가 다익스트라의 최소 누적 경로라고 할 수 없다.

예를 들어

정점 A, B, C가 있다고 가정하자

- w(A, B) = 2
- w(B, C) = 2
- w(A, C) = 3

MST는 A - B - C 를 각각 2로 연결하는 경로를 선택한다. 이 경우 A에서 C로 가려면 가중치 4 이다.

하지만 다익스트라는 시작 점을 A라고 한다면  A-C는 3이라는 경로를 선택할 것이다.