### 그래프에서 사용되는 자료구조

- 인접 행렬
    
    인접행렬은 직관적이고 특정 연결 검색이 빠르다는 장점이 있고
    
    단점으로는 간선이 듬성듬성 있을 경우 0이 너무 많아서 메모리 낭비가 있다는 점이다
    
- 인접리스트
    
    반대로 필요한 것만 저장하니까 메모리가 효율정인 장점이 있지만 특정 연결 정보 조회에 느리다는 단점이 존재한다
    

## DFS

구현 방식: **재귀 호출 vs stack**

- DFS의 구조를 보면 두 가지 방법이 떠오를 것이고 그 두 가지 방법으로 역시 구현이 가능하다.
- 그럼 각각의 장단점은 무엇이 있고 어떤 것을 활용하는 것이 좋을까?

**재귀 호출**

우선 재귀 호출의 장점은 구현이 쉽다는 점이다. 방문을 안했으면 방문표시를 하고 재귀호출을 해주면 된다. 단점은 느리고 재귀 깊이가 깊어지면 제한이 걸린다는 점이라고 할 수 있다. 이 방법은 코딩테스트에서 주로 사용하는 방법론이라고 할 수 있다

**stack**

stack의 장점은 ‘빠르다’라는 것이다. 효율적으로 구현이 가능하다는 것인데 때문에 실제 개발에서는 stack을 활용한 구현이 이루어진다고 한다. 단점은 구현이 어렵다는 점인데.. 아직 내 단계에서는 그렇게 어렵진 않은것 같다. 

그래도 생각해보면 재귀호출 방식으로 주로 사용하고 있었던 걸 보아 재귀가 더 쉽긴 한 것 같다.

## BFS

두 가지 버전이 있다. 큐에 추가하면서 방문체크와 큐에 꺼내면서 방문체크.

**큐에 추가하면서 방문체크를 하는 것이 중복으로 담는 경우를 줄이므로 더 효율적**이라고 할 수 있다. 

둘다 완전 탐색인데 어떤 경우에 각각을 사용하게 되는 것일까

- DFS는 경로를 출력하거나 갈 수 있는 경로의 수를 모두 구할 때
- BFS는 몇 번 만에 가는지? 최단 경로의 수를 구할 때 적용한다.

### why?

 만약에 지하철 한역에서 → 한역으로 가는 가장 효율적인 방법을 찾고 싶을때를 가정해보자.

 DFS를 쓰게되면 환승되는 역마다 깊게 들어가니까 비효율적인 방면으로 끝까지 탐색하고 또 다른 방면을 찾게된다. 

반면에 BFS는 넓게 뻗어나가면서 한번에 효율적인 동선을 찾게되고 이로써 효율적인 탐색이 가능하다.

만약에 미로나 모든 경로를 구하려고 한다면?

BFS는 각각 레벨별로 뻗어나가는 동선을 관리해야함 메모리적으로 각 동선을 가지고 있어야 해서 비효율적이다. 

그런데 DFS는 끝까지 뻗어나가면 그게 경로니까 +1해주면 알아서 관리가 되는 방식임. 이런 경우는 DFS가 효율적이라고 할 수 있다.

## 정리

그래프는 인접행렬, 인접리스트 자료구조를 활용하고 이를 탐색하는 DFS, BFS 두 개의 알고리즘이 있다.

둘 다 그래프를 완전 탐색하는 방법이지만 문제의 목적에 따라 적절하게 적용하는 것이 좋다.

---

## Union - find

서로소 집합 자료구조로 여러 원소를 그룹으로 관리하면서 

- 어떤 원소가 어떤 그룹에 속해있는지(find)
- 두 그룹을 합치기(Union)

하는 연산을 빠르게 수행하는 자료구조이다.

### 언제 사용할까

**”연결관계”**를 관리할 때 많이 사용한다

- 그래프 연결성 판단
    
    두 노드가 같은 컴포넌트에 속하는지 확인하고 싶을 때
    
- 사이클 판별
    
    크루스칼 알고리즘에서 MST 만들 때 사용
    
- 네트워크 연결 관리
    
    친구 관계, 집합 관계 등을 빠르게 병합/확인할 때 사용
    

### 효율을 높이는 방법 : 경로 압축

find()함수로 집합의 대표를 찾을 때 경로상의 모든 노드에게 대표를 직접적으로 연결한다.

→ 이로써 다음에 같은 노드를 찾을 때 훨씬 빨라진다

```python
def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])  # 루트로 경로 압축
    return parent[x]
```