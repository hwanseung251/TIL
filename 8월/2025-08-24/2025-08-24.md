**재귀로 구현할 때 넘기는 방식**

- 조합: 나 다음에 해당하는 애들을 재귀로 넘김
- 순열: 내가 선택한 거를 제외한 것들을 재귀로 넘김
- 부분 집합: 내가 이거 선택했을 때를 재귀로 넘김 & 내가 선택 안 했을 때 또한 재귀로 넘김

|  | 다음 재귀로 넘길 배열 범위 |  |
| --- | --- | --- |
| 조합 | `(arr[i + 1:], n - 1)` |  |
| 순열 | `(arr[:i] + arr[i + 1:], n - 1)` |  |
| 중복 조합 | `(arr[i:], n - 1)` |  |
| 중복 순열 | `(arr[:], n - 1)` |  |

### 부분 집합(Power Set)

- 집합에 포함된 원소들을 선택하는 것
- 많은 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는데 사용됨
    - 예) 배냥 짐싸기(Knapsack)
- **부분 집합의 수**
    - N개의 원소를 포함한 집합에서 공집합을 포함한 부분집합의 개수는 `$2^n$` 개
    - 각 원소를 부분집합에 포함하거나 포함하지 않는 2가지 경우를 모든 원소에 적용한 것

### {1, 2, 3} 집합의 모든 부분 집합을 재귀로 생성 (중요)

```python
def generate_subset(depth, included):
		if depth == len(input_list):
				cnt_subset = [input_list[i] for i in range(len(input_list)) if included[i]]
				subsets.append(cnt_subset )
				return
				
		included[depth] = False
		generate_subset(depth + 1, included)
		
		included[depth] = True
		generate_subset(depth + 1, included) 
		
input_list = [1, 2, 3] 
subsets = []
init_included = [False] * len(input_list)

generate_subset(0, init_included)
print(subsets)
```

<aside>
📌

만약 연산자 끼워넣기 에서 원소가 (포함 / 미포함) 이 아닌 (+ / - / x / %) 로 간다면, 위 코드를 4개의 재귀로 뻗어 나가도록 응용하면 됨.

</aside>

## 비트 연산

- 8비트 = 1바이트
- 10진수, 2진수 등
    - 10진수 예) $976 = 9 * 10^2 + 7 * 10^1 + 6 * 10^0$
    - 2진수 예) $7(10진수에서 7) = 0111(2진수에서 7) = 0 * 2^3 + 1 * 2^2 + 1 *2^1 + 1 * 2^0$
- 비트 연산자
    - `&` : 예) 5 & 3 = 0101 & 0011 = 0001 = 1
    - `|` : 예) 5 | 3 = 0101 | 0011 = 0111 = 7
    - `value << n` : value를 n비트만큼 왼쪽으로 이동(몇 바이트에서 진행되는지 알려줌, 예시는 8바이트)
        - 예)  $10 << 2 = 00001010 → 00101000 = 10 → 40$
    - `10&1<<3` : shift먼저 해줌 00001010 & 00001000 = 00001000 = 8

### {1,2,3} 집합의 모든 부분 집합을 “바이너리 카운팅” 으로 생성

```python
arr = [1, 2, 3]
n = len(arr)
subset_cnt = 2 ** n

subsets = []
for i in range(subset_cnt):
		subset = []
		for j in range(n):
				# i는 이미 부분집합을 비트로 표시중
				# j를 통해 그것을 확인 및 부분집합으로 추가
				if i & (1 << j):
						subset.append(arr[j]) 
		subsets.append(subset)
		
print(subsets)
```

### {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} 집합의 부분 집합의 합이 10인 부분 집합의 개수 구하기
```python
def sum_subset(depth, num_sum):
		"""
		depth: 현재 포함할지/말지를 선택하려고 하는 값의 인덱스
		"""
		global result
		# 종료 조건 : 앞에 요소들을 포함할지말지 다 결정했다는 의미
		if depth == N: 
				if num_sum == 10:
						result += 1
				return
		# 누적합이 10을 넘어서면 더이상 할 필요 없음
		# 단, 문제에서 주어진 숫자들이 다 0을 넘어선다면
		# 백트래킹(가지치기)
		if num_sum >= 10:
				return
		# depth에 해당하는 친구를 부분집합에 포함시키기로 결정했으면
		# 포함시키는 경우
		sum_subset(depth + 1, num_sum + arr[depth])
		# 포함시키지 않기로 결정
		# depth만 +1해주고, 누적값은 그대로 전달
		sum_subset(depth + 1, num_sum)

N = 10
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result = 0

"""
재귀를 구현할 때 파라미터를 뭘로 할까?
결국 재귀라는건 종료를 해아한다. 종료 조건이 필수
1. 재귀 호출을 중단시킬 파라미터 => 현재 포함할꺼냐/말꺼냐를 정할 요소의 인덱스
2. 우리가 원하는 누적값 => 여태까지 내가 선택한 숫자들의 합

====번외
모르겠다.. 도저히 모르겠다, 시작도 못하겠다 감이 안온다.
모든 변수를 다 넣어라 => 필요없으면 코드 작성하다가 지우고, 필요하면 추가로 만들어
"""
sum_subset(0, 0)
print(result)
```