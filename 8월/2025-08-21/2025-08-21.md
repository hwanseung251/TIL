# **1. 순열(Permutation)**

## **1.1 순열 개념**

- 주어진 원소들을 **순서 있게 나열**하는 것을 의미
    - 주어진 **서로 다른 원소들** 중에서 일부(r개) 혹은 전부(n개)를 **‘순서 있게’** 나열하는 방법
- 예를 들어, 3개의 원소 {1, 2, 3}가 있을 때, 이들을 **모두 사용**해서 순열을 만들면, 가능한 나열은 총 6가지
    - $(1,2,3), (1,3,2), (2,1,3), (2,3,1), (3,1,2), (3,2,1)$
- **순서**가 바뀌면 **다른** 경우로 취급 (예: (1,2,3) ≠ (3,2,1))
- 표기
    - 전체 원소가 n개 있을 때, **r개를 뽑아 순서 배열**하는 경우를 **`$nPr$`**이라고 표기
        - **`$nPr$`** = `$n * (n-1) * (n-2) * … * (n-r+1)$`
    - 모든 원소(n개)를 다 쓰는 순열은 **`$nPn$`**이 되며, 이는 `n!` (팩토리얼)과 동일
    - 예) 
    여행지 A,B,C를 방문할 때 가능한 경로는?
    n=3, r=3 → `$_3P_3$ = 3! = 6`

### **1.1.1 순열의 경우의 수**

1. 모든 원소를 다 사용하는 순열
    - 원소가 N개 → 순열의 개수 = **`$N!$`** (N 팩토리얼)
    - 예) N=3 → `$3!$` = 6
2. N개중 일부(r개) 원소만 선택해서 순서를 나열할 수도 있음(부분 순열)
    - `$nPr$` **= `$N! / (N-R)!$`**

## **1.2 순열 예시**

### **1.2.1 실생활 예시**

- 여행 경로: A, B, C라는 3개 도시를 모두 방문할 수 있는 순서를 나열하면 $_3P_3$ = 3!=6가지
    - $(A,B,C), (A,C,B), (B,A,C), (B,C,A), (C,A,B), (C,B,A)$
- **자리 배치**: N명의 학생이 줄을 서는 모든 경우 → `$n!$`
- **암호 조합**: 3자리 비밀번호 각 자리에 0~9를 넣는다면 10×10×10 = 1000가지 순열 (중복 포함 순열)

### **1.2.2 순열의 특징**

- **순서**가 핵심 → 위치가 달라지면 다른 결과
- 경우의 수가 빠르게 증가 (`$N!$`은 매우 큰 값)
    
    ![Screenshot 2025-08-19 at 2.57.26 PM.png](./image1.png)
    

## **1.3 순열 구현**

`{1, 2, 3}`의 모든 순열을 구하는 두 가지 방법

### **1.3.1 반복문 방식**

```python
# {1, 2, 3}의 모든 순열을 구하기 위한 3중 for문

for i in range(1, 4):
    for j in range(1, 4):
        # i와 j가 겹치지 않는 경우에만 다음 단계로
        if i != j:
            for k in range(1, 4):
                # i, j, k가 모두 겹치지 않는 경우 출력
                if i != k and j != k:
                    print(i, j, k)

```

```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

- **해설**
    - i, j, k는 모두 달라야 하므로 `if j != i`, `if k != i and k != j`를 검사
- **한계점**
    - 이 방식은 원소의 개수가 `3`개로 고정되어 있을 때는 유효하지만, 원소가 `4`개가 되면 `for`문을 4번, `n`개가 되면 `n`번 중첩해야 함
    - 이처럼 **원소의 개수가 유동적일 때는 사용할 수 없다**는 명확한 한계가 존재

### **1.3.2 재귀 방식**

<aside>
📌

"하나를 고르고, 남은 목록에서 고르는 경우의 수”

</aside>

이러한 한계를 극복하기 위해 재귀 함수를 사용

재귀적으로 “현재 원소를 선택” + “나머지 원소로 순열 구성”을 반복

```python
def perm(selected, remaining):
		'''
		Args:
				selected (list) : 현재까지 선택된 원소들의 순열 (선택된)
				remaining (list) : 아직 선택되지 않은 원소들 (선택할)
		'''
		
		if not remaining:
				print(selected)
				return
				
		for i in range(len(remaining)):
				pick = remaining[i]
				
				new_remaining = remaining[:i] + remaining[i+1:]
				perm(selected + [pick], new_remaining)
				
perm([], [1, 2, 3])
```

```
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]
```

- **재귀 코드 구현에서의 백트래킹**
    1. **선택:** `for` 루프 안에서 다음 자리에 올 원소를 고르는 부분
    2. **탐색:** 선택한 원소를 포함하여, 나머지를 가지고 재귀 호출하는 부분
    3. **복귀:** 재귀 호출이 끝나고 **원래의 `for` 루프로 돌아오는 과정**
- 이 중에서도 백트래킹의 핵심은 **3번, '복귀’**
    
    ```python
    def perm(selected, remaining):
        if not remaining:
            print(selected) # '막다른 길'에 도달해 탐색 성공
            return          # 이전 단계로 '복귀'
    
        for i in range(len(remaining)):
            # 1. 선택: i번째 원소를 선택하기로 결정
            pick = remaining[i]
            new_remaining = remaining[:i] + remaining[i+1:]
            
            # 2. 탐색: 선택한 결과를 가지고 더 깊이 들어감
            perm(selected + [pick], new_remaining)
            
        # 3. 복귀: for 루프의 다음 순회로 넘어가면서,
        #    이전의 pick은 자연스럽게 버려지고 새로운 i번째 원소를 선택하게 됨
        #    이것이 바로 이전 선택을 '취소'하고 다른 길을 탐색하는 백트래킹의 과정
    ```
    
    - `perm([1], [2, 3])` 호출이 끝나고 `for`문으로 돌아와 다음 차례인 `i=1` (원소 `3`)을 `pick`하는 순간이 바로, `1` 다음에 `2`를 선택했던 결정을 **'취소'하고 `3`을 선택하는 백트래킹**이 일어나는 지점

**[참고] 백트래킹이란?**

- 이처럼 재귀를 사용하여 모든 가능한 경우를 탐색하다가, 특정 조건(여기서는 원소를 하나 선택)을 만족하면 더 깊이 들어가고, 막다른 길에 다다르면(순열 완성) 다시 이전 상태로 돌아와 다른 선택을 하는 방식을 `백트래킹(Backtracking)`이라고 부름
- '재귀를 활용한 문제 해결 패턴 중 하나’라고 이해하기

---

# 2. 조합(Combination)

## **2.1 조합 개념**

> 피자 토핑 고르기 🍕
> 
- **조합**이란, 순서에 상관없이, **서로 다른 `n`개의 원소에서 `r`개를 선택하는 모든 경우의 수**
    - **여러 원소 중에서 ‘일부(r개)’만 골라 묶는 방법**이며, **순서가 중요하지 않다.**
- 마치 피자 토핑을 고르는 것과 같음. '페퍼로니'를 먼저 고르고 '치즈'를 고르든, '치즈'를 먼저 고르고 '페퍼로니'를 고르든, 최종적으로 피자에 올라간 토핑의 **'구성'은 동일**. 이처럼 조합은 **순서를 고려하지 않음**
- **정의**: 서로 다른 `n`개의 원소 중 순서에 상관없이 `r`개를 선택하는 방법
- **핵심**: `(1, 2)`와 `(2, 1)`은 같은 조합으로 취급
    - 예) `{1,2,3}` 중 2개를 택하는 조합: (1,2), (1,3), (2,3)
    - 예) `{1,2,3,4}` 중 2개씩 묶음을 만들면, (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)

### **2.1.1 조합의 경우의 수**

- N개 원소 중 R개를 고르는 조합
- `$nCr$` = **`$N! / (R!(N-R)!)$`**
    - 45개의 숫자 중 6개를 골라 로또 번호를 만드는 경우 → `$_{45}C_{6}$` ≈ `8,145,060`

## **2.2 조합 예시**

### **2.2.1 실생활 예시**

- **로또 번호**: 1~45 중 6개를 고르는 방법 (순서는 의미가 없음)
- **팀 구성**: 동아리원 중 3명 뽑아 대회 참가 (순서 상관없이 ‘누가 포함되느냐’만 중요)

## **2.3 조합 구현**

`{1, 2, 3, 4}`에서 `3`개를 뽑는 모든 조합을 만드는 두 가지 방법

### **2.3.1 반복문 방식**

```python
numbers = [1, 2, 3, 4]
n = len(numbers)

# 3개의 원소를 뽑으므로 3중 for문 사용
for i in range(n):
    for j in range(i + 1, n):
        for k in range(j + 1, n):
            print(numbers[i], numbers[j], numbers[k])
```

```
1 2 3
1 2 4
1 3 4
2 3 4
```

- **해설**:
    - $i<j<k$ 구조를 이용
    - `1<2<3`, `1<2<4`, `1<3<4`, `2<3<4`
    - 다음 반복문의 시작 범위를 이전 반복문보다 1 크게 설정
    - `range(i + 1, ...)` 덕분에 `i`번째에서 선택된 숫자보다 작은 숫자는 `j`번째에서 아예 고려되지 않음. 이 간단한 규칙만으로 순서가 다른 중복 조합을 자연스럽게 제거할 수 있음

### **2.3.2 재귀 방식**

<aside>
📌

**'결정의 연속’**
"현재 요소를 포함시킬지" 결정하고, "나머지 요소들로 나머지 개수를 채우는" 재귀적 구조

</aside>

1. 첫 번째 원소(`1`)를 **결정**했다고 가정
2. 이제 **나머지 원소(`{2, 3, 4}`)** 중에서 **나머지 개수(`2`개)**를 뽑는 모든 조합을 구하라고 재귀 호출
3. 위 과정이 끝나면, 다시 돌아와 첫 번째 원소를 **결정하지 않았다**고 가정하고, **나머지 원소(`{2, 3, 4}`)** 중에서 **뽑아야 할 개수(`3`개)**를 모두 뽑으라고 재귀 호출

```python
def comb(arr, r):
		"""
		Args:
				arr (list) : 원본 배열
				r (int) : 뽑을 개수
				
		Returns:
				list: 모든 조합이 담긴 2차원 리스트
		"""
		result = []
		
		if r == 0:
				return [[]]
				
		for i in range(len(arr)):
				# 값하나 선택
				elem = arr[i]
				# 선택한 값 제외하고 조합 재귀호출
				for rest in comb(arr[i+1:], r-1):
						# 최종 결과에는 각각의 조합값이 넣어짐
						result.append([elem] + rest)
		return result
		
all_combs = comb([1, 2, 3, 4], 3)
print(all_combs)
```

```
[[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]
```

---

# **3. 순열 vs. 조합**

원소 선택 시 **순서를 구별**하는지 여부가 가장 큰 차이.

| 항목 | 순열 | 조합 |
| --- | --- | --- |
| 개념 | 원소를 **순서 있게** 나열 | 원소 중 **일부를 ‘순서 무관’** 선택 |
| 예시 | (1,2,3) vs. (2,1,3) → **다른** 순열 | (1,2,3) vs. (3,2,1) → **같은** 조합 |
| 표기 | $nPr = n! / (n-r)!$ | $nCr = n! / (r!(n-r)!)$ |
| 개수 | $n! / (n-r)!$ | $n! / (r!(n-r)!)$ |
| 활용 예 | 줄 세우기, 암호, 경로 순서, … | 로또, 팀 구성, 조합 식 계산, … |
| 핵심 | 순서 바뀌면 다른 결과 | 순서 바뀌어도 같은 결과 |
- 순열: “순서가 달라지면 별개의 경우”
- 조합: “어떤 원소를 골랐는지가 중요, 순서는 무관”

---

# **4. 정리**

> **“순열”**은, 
순서가 중요한 배치나 경로 문제(Traveling, 등)와 밀접.

**“조합”**은, 
일상에서 “조합(Combination)”이나 “부분집합 선택” 등의 문제와 이어짐.
> 
1. **순열**
    - **모든 요소**(혹은 일부)를 **순서 있게 나열**해야 할 때
    - 예: 경로 탐색, 줄세우기, 암호 생성 등
    - 경우의 수가 N!로 빠르게 증가 → N이 작을 때만 완전 탐색 가능
2. **조합**
    - **어떤 원소를 뽑느냐**만 중요(순서는 중요X)
    - 예: 로또, 팀 구성, 부분집합(정해진 크기)
3. **구현 방식**
    - **반복문** (단순 but 확장성 낮음)
    - **재귀(백트래킹)** (N이 커져도 유연)
    - **비트마스크**, 등

두 개념은 **완전 탐색**, **백트래킹** 등에서 자주 등장하며,

N이 작을 때는 **중첩 반복**으로, N이 커지면 **재귀**(혹은 다른 기법)로 구현해 **모든 경우**를 나열 가능


# **순열과 조합 (with `itertools`)**

파이썬에서 순열과 조합을 쉽게 다룰 수 있도록, 표준 라이브러리 `itertools`에서는 **`permutations`**와 **`combinations`** 함수를 제공한다. 

각 함수는 **반복 가능한(iterable) 객체**를 입력 받아, 순열 혹은 조합을 **튜플 형태**로 차례대로 만들어준다.

---

---

# **1. 순열**

## **1.1 `permutations()`**

```python
**itertools.permutations(iterable, r=None)**
```

- 주어진 iterable에서 **중복 없이** 원소를 골라, 길이 `r`의 **순열**을 생성
- 순열이므로 **원소의 나열 순서**가 달라지면 **다른 결과**
- `r`이 `None`이면 기본 값은 `len(iterable)` → **전부** 사용하는 순열
- 입력된 원소가 고유하다면, 각 순열 결과에도 **중복 원소**가 나타나지 않음
- iterable이 정렬되어 있으면, 순열 결과도 **정렬된 순서**로 생성

**예시**

- `permutations('ABCD', 2)` → 길이 2짜리 순열을 생성
    - 결과: `('A','B'), ('A','C'), ('A','D'), ('B','A'), ('B','C'), ... (D','C')` 등

## **1.2 `permutations()` 예시 코드**

```python
import itertools

data_list = ['A', 'B', 'C', 'D']
```

```python
# permutations()는 반복 가능한 객체를 반환 (제너레이터)
result_object = itertools.permutations(data_list, 2)
print(result_object)  # <itertools.permutations object at 0x...>

# 실제 결과를 보고 싶으면 list() 등으로 변환
result_list = list(itertools.permutations(data_list, 2))
print(result_list)
# [('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'A'), ('B', 'C'), ('B', 'D'),
#  ('C', 'A'), ('C', 'B'), ('C', 'D'), ('D', 'A'), ('D', 'B'), ('D', 'C')]

# 문자열로 합쳐 보기
print(list(map(''.join, result_list)))
# ['AB', 'AC', 'AD', 'BA', 'BC', 'BD', 'CA', 'CB', 'CD', 'DA', 'DB', 'DC']

```

```python
# 직접 for문으로 순회

for perm_tuple in itertools.permutations('ABCD', 2):
    print(''.join(perm_tuple), end=' ')
# AB AC AD BA BC BD CA CB CD DA DB DC
```

```python
# 숫자 예시: permutations(range(3)) => 3개의 원소 전체 순열

for perm_tuple in itertools.permutations(range(3)):
    print(''.join(map(str, perm_tuple)), end=' ')
# 012 021 102 120 201 210
```

**해설**

1. `permutations(iterable, 2)`는 `iterable`에서 2개씩 뽑는 모든 순열을 만든다.
2. 반환 값은 **제너레이터**(한 번 순회 후 소모되는 객체)
3. `map(''.join, ...)` → 튜플을 문자열로 합쳐 출력

---

## **2. 조합**

### **2.1 combinations()**

**itertools.combinations(iterable, r)**

주어진 iterable에서 **원소 r개를 중복 없이** 뽑되, **순서는 고려하지 않는** 조합을 생성

입력이 정렬돼 있으면 결과도 정렬된 순서로 생성

**예시**

combinations('ABCD',2) →(′A′,′B′),(′A′,′C′),(′A′,′D′),(′B′,′C′),(′B′,′D′),(′C′,′D′)(′*A*′,′*B*′),(′*A*′,′*C*′),(′*A*′,′*D*′),(′*B*′,′*C*′),(′*B*′,′*D*′),(′*C*′,′*D*′)

로또 번호(1~45 중 6개) → combinations(range(1,46), 6)

### **2.2 combinations() 예시 코드**

```python
import itertools

data_list = ['A', 'B', 'C', 'D']
```

```python
# combinations()도 제너레이터
result_object = itertools.combinations(data_list, 2)
print(result_object)  # <itertools.combinations object at 0x...>

# list()로 변환해 확인
result_list = list(itertools.combinations(data_list, 2))
print(result_list)
# [('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('B', 'D'), ('C', 'D')]

# 문자열로 합쳐서 보려면
print(list(map(''.join, result_list)))
# ['AB', 'AC', 'AD', 'BC', 'BD', 'CD']
```

```python
# 직접 for문으로 순회

for comb_tuple in itertools.combinations('ABCD', 2):
    print(''.join(comb_tuple), end=' ')
# AB AC AD BC BD CD

```

```python
# 숫자 예시: combinations(range(4), 3)

for comb_tuple in itertools.combinations(range(4), 3):
    print(''.join(map(str, comb_tuple)), end=' ')
# 012 013 023 123
```

**해설**

1. `combinations(iterable, 2)`는 iterable에서 2개씩 뽑는 **순서 무관** 조합을 생성
2. 출력은 튜플이지만, `'A','B'`와 `'B','A'`는 같은 조합으로, 내부에서 하나만 생성

---

# **3. [참고] 중복 순열/조합**

## 3.1 중복 순열

- 순서를 고려하여 여러 번 선택할 수 있게 나열하는 모든 가능한 방법
- **중복을 허용**하는 **순열** (데카르트 곱)

```python
itertools.product(iterable, repeat=r)
```

- 예) 비밀번호를 생성할 때, 각 자리의 문자는 중복될 수 있으며 순서를 고려해야 한다.
- 예) `product('AB', repeat=2)` 
→ $(‘A’,‘A’), (‘A’,‘B’), (‘B’,‘A’), (‘B’,‘B’)$

## 3.2 중복 조합

```python
itertools.combinations_with_replacement(iterable, r)
```

- **중복을 허용**하는 **조합**
- 예) `combinations_with_replacement('ABC', 2)` 
→ $(‘A’,‘A’), (‘A’,‘B’), (‘A’,‘C’), (‘B’,‘B’), (‘B’,‘C’), (‘C’,‘C’)$

**예시 코드**

```python
# product - 중복 순열

data_list = ['A', 'B', 'C']
prod_result = list(itertools.product(data_list, repeat=2))

print(prod_result)
# [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'B'), ('B', 'C'), ('C', 'A'), ('C', 'B'), ('C', 'C')]

```

```python
# combinations_with_replacement - 중복 조합

data_list2 = ['A', 'B', 'C']
comb_wr_result = list(itertools.combinations_with_replacement(data_list2, 2))

print(comb_wr_result)
# [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'B'), ('B', 'C'), ('C', 'C')]

```

**해설**

- **`product(..., repeat=r)`**
    - r개 자리를 모두 채우되, **같은 원소**를 여러 번 사용 가능 (순서 있음)
- **`combinations_with_replacement(..., r)`**
    - r개를 뽑는 **조합**에서, **같은 원소**도 여러 번 선택 가능 (순서 없음)

---

# **4. [주의사항] 제너레이터의 소모**

- **`combinations`**, **`permutations`** 모두 **반복자(iterator)** 형태로 결과를 생성 (일종의 제너레이터)
- 한 번 순회가 끝나면 **재사용 불가**
- 예시
    
    ```python
    import itertools
    
    data_list = ['A', 'B', 'C', 'D']
    
    comb_obj = itertools.combinations(data_list, 2)
    
    # 첫 번째 순회
    for pair in comb_obj:
        print(pair)
    # ('A','B'), ('A','C'), ('A','D'), ('B','C'), ('B','D'), ('C','D')
    
    print(list(comb_obj))
    # []
    # 이미 comb_obj를 소진했으므로 빈 리스트 []
    
    # 필요한 경우, list()로 먼저 변환해두고 여러 번 재사용
    ```
    
    **정리**
    
    - 결과를 여러 번 사용하려면, **리스트나 튜플** 등으로 **한 번 변환**해 저장해야 한다.
    - 아니면 새로 `combinations(...)` 혹은 `permutations(...)`를 다시 호출해 객체를 만들어야 한다.

---

# **5. 정리**

- **`permutations()`**: **순서**를 고려하는 길이 `r`의 순열 생성
- **`combinations()`**: **순서 무관**으로 `r`개를 고르는 조합 생성
- 모두 **반복자**(제너레이터) 형태 → 한 번 순회 후 소진되니 주의
- 중복이 필요하거나 다른 변형이 필요한 경우, `product`, `combinations_with_replacement` 등을 활용 가능

`itertools`를 통해 순열/조합을 매우 간단히 구현할 수 있으므로, **N이 작을 때**나 특정 용도로 빠른 시도에 유용.

하지만 대규모 데이터에서는 순열/조합 생성 개수가 기하 급수적으로 늘 수 있음에 유의해야 한다.