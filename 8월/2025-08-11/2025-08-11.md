## 연산

- **문자열 뒤집기**
  
  - 문자열을 역순으로 재정의
    
    ```python
    s = 'Reverse this strings'
    s = s[::-1]  # 'sgnirts siht esreveR' 
    ```
  
  - 리스트로 변환 후 다시 문자열로 변환
    
    ```python
    s = 'abcd'
    s = list(s)
    s.reverse()
    s = "".join(s)
    ```

- **화문**
  
  - 거꾸로 읽어도 똑같은 문장이나 낱말
    
    - 문자열 길이의 반만 비교하면 됨
    
    ```python
    def is_palindrome(txt):
            for i in range(len(txt)//2):
                    if txt[i] != txt[-1-i]
                            return False
            return True
    ```

---

## 문자열 비교

- `==` 연산자와 `is` 연산자
  
  - `==` 는 값이 같은지를 비교함
  - `is` 는 객체의 정체성, 즉 **같은 객체(메모리 주소)** 인지 비교
  - `==` 연산자는 내부적으로 특수 메서드 `__eq__()`를 호출함
  
  ```python
  a = [1, 2, 3]
  b = [1, 2, 3]
  
  print(a == b)  # True0
  print(a is b)  # False
  ```

- C 언어의 문자열 비교
  
  - strcmp() 함수를 사용해 문자열의 내용을 비교

- Java
  
  - `==` 연산자는 객체의 주소(참조)를 비교함. (Python의 is 연산자 역할)
  - `equals()` 메소드는 객체의 내용을 비교함. (Python의 == 역할)

### 사전 순서 비교

- 비교 연산자 `<` 사용
  
  - 유니코드를 비교
  
  ```python
  def my_strcmp(s1, s2):
          if s1 < s2:
                  return -1
          elif s1 > s2:
                  return 1
          else:
                  return 0
  ```

### 문자열 숫자를 숫자로 변환

```python
a = int('123')
b = float('3.14')
c = int('A0', 16)

# 다시 숫자를 문자열로 변환
a = str(123)
b = str(3.14)
```

---

## 패턴 매칭

### 고지식한 패턴 검색 (Brute Force)

- 단순한 방법
  
  - 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식
  
  ```python
  def brute_force(p, t):
          i = 0  # t의 인덱스
          j = 0  # p의 인덱스
          M = len(p)
          N = len(t)
          while j < M and i < N:
                  if t[i] != p[j]:
                          i = i - j
                          j = -1
                  i += 1
                  j += 1
          if j == M:
                  return i - M
          else:
                  return -1
  ```

- **시간 복잡도**
  
  - 최악의 경우 텍스트의 모든 위치에서 패턴을 비교해야 하므로 `O(MN)`이 됨
  - 길이가 10,000인 문자열에서 길이 80인 패턴을 찾는 경우
    - 최악의 경우 약 10,000*80 = 800,000 번의 비교가 필요

### KMP 알고리즘

- 패턴의 각 위치에서 매칭에 실패했을 때 돌아갈 위치를 미리 계산
  
  - 불일치가 발생한 글자의 앞 부분에 어떤 문자가 있는지 미리 알고 있게 됨
  - 조건에 따라, 불일치가 발생한 앞 부분에 대해 다시 비교하지 않을 수 있음
  - 불일치가 발생했을 경우 다음 위치를 계산하는 전처리가 필요

- 시간 복잡도
  
  - 패턴의 길이가 M일 때 전처리에 걸리는 시간은 `O(M)`
  - 텍스트의 길이가 N일 때 검색은 최악으 ㅣ경우 `O(N)`
  - 결과적으로 `O(M+N)` 이 됨
  - 만약 M이 고정된 값으로 매우 짧다면 평균적으로 `세타(N)` 이 됨

- **LPS** 배열
  
  - 접두사이자 접미사인 문자열의 최대 길이
  - 일치하지 않을 때 비교할 인덱스
  - 구현에 따라 next, pi 배열로도 불림

### 보이어 무어(Boyer-Moore) 알고리즘

- 상용 소프트웨어에서 채택하고 있는 알고리즘

- 실제 검색에서 매우 빠른 성능
  
  - 패턴 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 패턴의 길이 만큼이 됨

- 불일치 문자 휴리스틱
  
  - 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재할 경우
    - 불일치 문자 오른쪽에서 일치한 부분을 고려해 점프함
