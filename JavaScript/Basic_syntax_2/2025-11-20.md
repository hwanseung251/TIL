# 객체

## 구조 및 속성

### 객체 구조

자바스크립트의 객체(Object)는 **파이썬의 딕셔너리와 동일한 key-value 구조**이다.

- 중괄호 `{}` 로 생성
- key는 반드시 문자열로 처리되며, value는 어떠한 자료형도 올 수 있다(숫자, 문자열, 함수 포함).
- 하나의 객체 안에 여러 속성을 저장하는 자료형이다.

### 속성 참조

두 가지 방식이 존재한다.

- **점 표기법** : `user.name`
- **대괄호 표기법** : `user["name"]`
    - 대괄호 표기법은 **변수로 key를 접근할 때** 필수적이다.

### in 연산자

객체 안에 특정 key가 존재하는지 검사한다.

```jsx
"name" in user   // true
```

다만 `in`은 **프로토타입 체인까지 검사**하므로, 상속된 속성까지 true가 될 수 있다.

→ 이를 피하려면 `hasOwnProperty()` 또는 `Object.hasOwn()` 사용을 권장한다.

## 메서드

### this keyword

객체 내부 함수(메서드)에서는 `this`가 **메서드를 호출한 객체 자신**을 의미한다.

파이썬의 `self`와 완전히 동일한 개념이다.

251119 코딩 Live강의 Python, 마이스터고 …

### JavaScript에서 this는 '호출하는 방법'에 따라 달라진다

- **일반 함수 호출**: `this` → 전역 객체(window)
- **객체의 메서드 호출**: `this` → 해당 객체
    
    251119 코딩 Live강의 Python, 마이스터고 …
    

### 단순 호출 this

객체에 속하지 않은 일반 함수에서 `this`를 사용하면 전역 객체를 가리킨다.

251119 코딩 Live강의 Python, 마이스터고 …

### 메서드 호출 시 this

객체 내부 함수에서 `this`는 그 메서드를 호출한 객체를 뜻한다.

```jsx
const person = {
  name: "Alice",
  greeting() { console.log(this.name) }
}
person.greeting() // "Alice"
```

### 중첩된 함수에서의 this 문제

`forEach`와 같은 Helper Method 안에서 사용되는 일반 함수는 **this를 잃어버리고** 전역 객체를 가리킨다.

### 해결책

중첩 함수에서 this가 바뀌는 문제는 **화살표 함수**로 해결한다.

화살표 함수는 **자신만의 this를 갖지 않고**, 바깥 스코프의 this를 그대로 사용한다.

251119 코딩 Live강의 Python, 마이스터고 …

### JavaScript 'this' 정리

- this는 **정적으로 결정되지 않고**, “함수가 어떻게 호출되었는지”에 따라 동적으로 결정된다.
- 중첩 함수 this 문제는 화살표 함수로 해결할 수 있다.

## 추가 객체 문법

### 1. 단축 속성

key와 value의 변수명이 동일할 때 축약 가능하다.

```jsx
const name = "Alice"
const age = 30

const user = { name, age }
```

### 2. 단축 메서드

```jsx
const obj = {
  say() { console.log("hi") }
}
```

### 3. 계산된 속성

변수를 key로 사용할 때 유용하다.

```jsx
const key = "title"
const obj = { [key]: "JS 강의" }

```

단, 동적으로 key를 생성할 때는 **중복 key 위험**을 주의해야 한다.

### 4. 구조 분해 할당

객체 내부 값을 쉽게 꺼내오는 문법.

```jsx
const user = { name: "Alice", age: 30 }
const { name, age } = user

```

함수 파라미터에서도 사용 가능.

### 5. 객체와 전개 구문

얕은 복사 및 확장에 사용된다.

```jsx
const copy = { ...user }
```

### 6. 유용한 객체 메서드

- `Object.keys(obj)` : key 목록 반환
- `Object.values(obj)` : value 목록 반환
- `Object.entries(obj)` : [key, value] 쌍 목록 반환

### 7. Optional chaining ('?.')

존재할 수도, 없을 수도 있는 속성에 안전하게 접근하는 문법.

```jsx
user?.address?.street
```

단, **필수값이 아닌 데이터에만 사용해야 함.**

없는 데이터에 접근했는데도 에러가 나지 않기 때문에, 잘못된 데이터 검증을 놓칠 수 있다.

## JSON

- JSON은 **텍스트 기반 데이터 형식**
- 서버와 클라이언트 간 데이터 전달에 사용됨
- 텍스트로 받은 JSON을 JS 객체로 바꿀 때:
    - `JSON.parse()`
- 객체를 JSON 문자열로 바꿀 때:
    - `JSON.stringify()`

# 배열

## 배열 구조

- 순서가 있는 데이터 집합
- 모든 자료형을 요소로 가질 수 있음
- `length` 속성으로 길이 확인

## 배열 메서드

### push()

배열 끝에 요소 추가. 원본 배열 변경.

### pop()

배열 끝 요소 제거 후 반환. 원본 변경.

### unshift()

배열 앞에 요소 추가.

→ 모든 요소를 뒤로 밀기 때문에 **성능 저하**

### shift()

배열 앞 요소 제거.

→ 앞 요소 삭제 시 배열 전체 재정렬 필요 → **성능 저하**

## Array Helper methods

### 콜백 함수

콜백 함수는 **외부 함수에 의해 호출되는 함수**이다.

forEach, map, filter 등 배열 메서드에서 필수적으로 사용된다.

### 주요 Array Helper Methods

### forEach

- 모든 배열 요소에 대해 콜백 함수 실행
- **반환값 없음**
- 단순 반복용

### map

- 모든 요소에 콜백을 적용하고
- **변환된 값들로 새로운 배열을 반환**

## 배열 순회 종합

### 배열 순회 정리

- 반복하며 처리 → forEach
- 변환해서 새로운 배열 만들기 → map
- 존재 여부 검사 → some
- 모두 조건 충족 확인 → every

### 기타 Array Helper Methods

- filter
- reduce
- some / every
    
    (강의에서는 reduce를 실무에서 많이 사용한다고 언급)
    

### 배열 with 전개 구문

배열 복사 및 병합에 사용.

```jsx
const arr2 = [...arr1]
```

## 클래스

(강의 후반부에서 new 관련 설명이 이어진다고 언급만 되었으므로 기본 개념만 포함)

- 객체를 생성하는 템플릿
- `new` 연산자를 사용해 인스턴스 생성

---

## new 연산자

- 생성자 함수를 통해 새로운 객체(인스턴스)를 만든다.

---

## 콜백함수 구조를 사용하는 이유

### 함수 유연성 측면

- 특정 시점에서 원하는 동작을 외부에서 주입 가능
- 재사용성 및 확장성 증가

### 비동기적 측면

- 타이머, 이벤트, API 응답 등 **“나중에 실행해야 하는 작업”**에 필수적

## forEach에서는 break 사용하기

- forEach는 break를 지원하지 않음
- 대신
    - `some()` : 조건 만족하면 중단
    - `every()` : 조건 불만족하면 중단
        
        을 활용 가능
        

## 배열은 객체다

JS에서 배열도 객체이므로 키/값 구조이며, 다만 인덱스라는 특별한 key를 사용한다.

## Reduce 메서드

- 모든 요소를 누적 계산하여 하나의 결과를 만드는 메서드
- 실무에서 빈번하게 사용되는 고급 Helper Method