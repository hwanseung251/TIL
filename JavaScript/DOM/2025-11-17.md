# ECMAScript

- Ecma International이 정의한 “표준화된 스크립트 프로그래밍 언어 명세”

→ 스크립트 언어가 준수해야 하는 규칙, 세부사항 등을 정의 

## ECMAScript와 JavaScript

- JavaScript는 ECMAScript 표준을 구현한 구체적인 프로그래밍 언어
- ECMAScript의 명세를 기반으로 하여 웹 브라우저나 Node.js와 같은 환경에서 실행됨

→ ECMAScript는 JavaScript의 표준이며, JavaScript는 ECMAScript 표준을 따르는 구체적인 프로그래밍 언어 

→ ECMAScript는 언어의 핵심을 정의하고, JavaScript는 ECMAScript 표준을 따라 구현된 언어로 사용됨 

### JavaScript의 현재와 미래

- 현재는 다양한 웹 브라우저가 경쟁하고 있으며, 모바일 등 시장이 다양화 되어있음
- 과거에는 JavaScript가 브라우저 내에서 웹 페이지의 동적인 기능을 구현하는 용도로만 사용되었음
- 이후 Node.js로 인해 브라우저 외부에서도 실행 가능해져 서버 가이드 개발에도 사용되기 시작함
- 다양한 프레임워크와 라이브러리들이 개발되면서, 웹 개발 분야에서는 필수적인 언어로 자리 잡게 됨

## 변수 작성 규칙

### 식별자(변수명) 작성 규칙

- 반드시 문자, 달러(’$’) 또는 밑줄(’_’)로 시작
- 대소문자를 구분
- 예약어 사용 불가
    - for, if, function 등

### 식별자(변수명) Naming Convention

- 카멜 케이스(camelCase)
    - 변수, 객체, 함수에 사용
- 파스칼 케이스(PascalCase)
    - 클래스, 생성자에 사용
- 대문자 스네이크 케이스(SNAKE_CASE)
    - 상수(constants)에 사용

<aside>
💡

- 문법이 아닌 ‘소통’의 규칙임으로 소통 도구임을 이해해야 함
- 가장 중요한 것은 ‘일관성’ 이고, 팀의 스타일 가이드를 따르는 것이 우선
</aside>

## 변수 선언 키워드

1. `let` 
    - 재할당이 필요한 변수를 선언할 때 사용
2. `const`
    - 재할당이 불가능한 상수를 선언할 때 사용
3. `~~var~~`
    - 재선언/재할당이 가능하고, 현재는 **호이스팅(Hoisting)** 문제로 사용을 권장하지 않음

### let : 블록 스코프를 갖는 지역 변수를 선언

1. 재할당 가능
2. 재선언 불가능
3. ES6에서 추가

```jsx
let number = 10 // 1. 선언 및 초기값 할당
number = 20 // 2. 재할당

let number = 10 // 1. 선언 및 초기값 할당
let number = 20 // 2. 재선언 불가능 
```

### const : 블록 스코프를 갖는 지역 변수를 선언

1. 재할당 불가능
2. 재선언 불가능
3. ES6에서 추가 

```jsx
const number = 10 // 1. 선언 및 초기값 할당
number = 10 // 2. 재할당 불가능 

const number = 10 // 1. 선언 및 초기값 할당
const number = 10 // 2. 재선언 불가능
const number // const' declarations must be initialized. 
```

### 블록 스코프(block scope)

- if, for, 함수 등의 ‘중괄호({}) 내부’를 가리킴
- 블록 스코프를 가지는 변수는 블록 바깥에서 접근 불가능

```jsx
let x = 1
if (x === 1) {
		let x = 2
		console.log(x) // 2
}
console.log(x) // 1 
```

### 어떤 변수 선언 키워드를 사용해야 할까?

- “const를 기본으로 사용할 것”
    - 코드의 의도 명확화
        - 해당 변수가 재할당되지 않을 것임을 명확히 표현
        - 개발자들에게 변수의 용도와 동작을 더 쉽게 이해할 수 있게 해줌
    - 버그 예방
        - 의도치 않은 변수 값 변경으로 인한 버그를 예방
        - 큰 규모의 프로젝트나 팀 작업에서 중요
- 필요한 경우에만 let 으로 전환(재할당이 필요한 경우)
    - let 을 사용하는 것은 해당 변수가 의도적으로 변경될 수 있음을 명확히 나타냄
    - 코드의 유연성을 확보하면서 const의 장점을 최대한 활용할 수 있음

# DOM

웹 페이지를 구조화된 객체로 제공하여 프로그래밍 언어가 페이지 구조에 접근할 수 있는 방법을 제공 

## 웹 브라우저에서의 JavaScript

- 웹 페이지에서 동적인 기능을 담당

## 문서 구조

- HTML 문서는 여러 상자가 중첩된 구조
- 각 상자는 객체이며 개발자는 이 객체와 상호작용하며 어떤 HTML 태그를 나타내는지, 어떤 콘텐츠가 포함되어 있는지 알아낼 수 있음
- 이 표현을 **DOM**(Document Object Model) 이라고 부름

### DOM API

- 다른 프로그래밍 언어가 웹 페이지에 접근 및 조작할 수 있도록, 페이지 요소들을 객체 형태로 제공하며 관련된 메서드도 함께 제공
- HTML 구조와 내용을 조작하는 명령어 모음

### document 객체

- 웹 페이지를 나타내는 DOM 트리의 최상위 객체
- HTML 문서의 모든 콘텐츠에 접근하고 조작할 수 있는 진입점

## DOM Tree

- HTML 태그를 나타내는 elements의 node는 문서의 구조를 결정
- 이들은 다시 자식 node를 가질 수 있음

![image.png](./image.png)

### DOM 핵심

문서의 요소들을 객체로 제공하여 다른 프로그래밍 언어에서 접근하고 조작할 수 있는 방법을 제공하는 API 

### DOM 조작 시 기억해야 할 것

**웹 페이지를 동적으로 만들기** == **웹 페이지를 조작하기**

조작 순서

1. 조작 하과 하는 요소를 선택
2. 선택된 요소의 콘텐츠 또는 속성을 조작 

## 선택 메서드

`document.querySelector(selector)`

- 요소 한 개 선택(예: 특정 id, class 또는 태그에 해당하는 첫 번째 요소를 찾을 때)
- 제공한 선택자와 일치하는 첫 번째 요소를 하나 선택
- 제공한 선택자를 만족하는 첫 번째 element 객체를 반환(없다면 null 반환)

```jsx
const firstButton = document.querySelector('button');
firstButton.textContent = "버튼 텍스트 변경";
```

- **왜 사용?**: 하나의 요소를 대상으로 작업할 때 간단하게 사용할 수 있다.
- **어떻게 사용?**: 주어진 선택자에 해당하는 **첫 번째 요소**를 찾고, 그 요소에 대해 작업을 진행.

`document.querySelectorAll(selector)`

- 요소 여러 개 선택
- 제공한 선택자와 일치하는 여러 element를 선택
- 제공한 선택자를 만족하는 NodeList를 반환

```jsx
const allButtons = document.querySelectorAll('button')
allButtons.forEach(button => {
  button.textContent = "모든 버튼 텍스트 변경"
})
```

- **왜 사용?**: 여러 요소를 한번에 다루기 위해 사용.
- **어떻게 사용?**: 선택자에 맞는 모든 요소를 **NodeList**로 반환하고, 이를 **forEach**로 반복하여 각 요소에 대한 작업을 할 수 있다.

# DOM 조작

### 속성 조작

1. 클래스 속성 조작
    - 스타일링 및 상태 제어를 위한 클래스 목록을 동적으로 추가/제거
2. 일반 속성 조작
    - id, href 등 요소의 모든 HTML 속성 값을 직접 설정/조회

## 1. 클래스 속성 조작 ‘classList’ property

- 요소의 클래스 목록을 유사 배열 형태로 반환
- HTML 요소의 클래스 목록을 쉽게 제어(추가/제거)하는 도구

### classList 메서드

- `element.classList.add()`
    - 지정한 클래스 값을 추가
    
    ```jsx
    const element = document.querySelector('.box');
    element.classList.add('active');  // 'active' 클래스 추가
    ```
    
- `element.classList.remove()`
    - 지정한 클래스 값을 제거
    
    ```jsx
    const element = document.querySelector('.box');
    element.classList.remove('active');  // 'active' 클래스 제거
    ```
    
- `element.classList.toggle()`
    - 클래스가 존재한다면 제거하고 false를 반환 (존재하지 않으면 클래스를 추가하고 true를 반환)
    
    ```jsx
    const element = document.querySelector('.box');
    element.classList.toggle('active');  // 'active' 클래스가 없으면 추가, 있으면 제거
    ```
    

### 일반 속성 조작 메서드

- `Element.getAttribute()`
    - 해당 요소에 지정된 값을 반환(조회)
    - 특정 요소의 속성 값을 가져올 때 사용
    
    ```jsx
    const link = document.querySelector('a')
    const hrefValue = link.getAttribute('href')  // href 속성 값 가져오기
    console.log(hrefValue)
    ```
    
    - **왜 사용?**: 특정 요소의 속성 값을 조회하고 싶을 때 유용하다.
    
- `Element.setAttribute(name, value)`
    - 지정된 요소의 속성 값을 설정
    - 속성이 이미 있으면 기존 값을 갱신(그렇지 않으면 지정된 이름과 값으로 새 속성이 추가)
    
    ```jsx
    const link = document.querySelector('a')
    link.setAttribute('href', 'https://www.new-url.com')  // href 속성 변경
    ```
    
- `Element.removeAttribute()`
    - 요소에서 지정된 이름을 가진 속성 제거
    
    ```jsx
    const link = document.querySelector('a')
    link.removeAttribute('href')  // href 속성 제거
    ```
    

## 2. HTML 콘텐츠 조작 ‘textContent’ property

- 요소의 텍스트 콘텐츠를 표현

```jsx
const h1Tag = document.querySelector('.heading')
h1Tag.textContent = '내용 수정'
```

## 3. DOM 요소 조작

- `document.createElement(tagName)`
    - 작성한 tagName의 HTML 요소를 생성하여 반환
    - 새로운 HTML **태그**를 동적으로 생성할 때 사용
    - 새로운 요소를 페이지에 추가하고자 할 때 사용
    
    ```jsx
    const newDiv = document.createElement('div')
    newDiv.textContent = '새로운 div 태그입니다.'
    document.body.appendChild(newDiv) // body에 새로운 div 태그 추가
    ```
    
    - **왜 사용?**: 기존 HTML 마크업에 추가할 새로운 요소를 생성할 때 유용하다.
    - **어떻게 사용?**: `createElement`를 사용하여 새 태그를 만들고, `appendChild`를 통해 DOM에 삽입한다.
- `Node.appendChild()`
    - 한 Node를 특정 부모 Node의 자식 NodeList 중 마지막 자식으로 삽입
    - 추가된 Node 객체를 반환
    
    ```jsx
    const newDiv = document.createElement('div')
    document.body.appendChild(newDiv)  // body에 newDiv 추가
    ```
    
    - 동적으로 생성한 자식 요소를 부모 요소에 추가하고 싶을 때 유용하다.
- `Node.removeChild()`
    - DOM에서 자식 Node를 제거
    - 제거된 Node를 반환
    
    ```jsx
    const parent = document.querySelector('div')
    const child = parent.querySelector('span')
    parent.removeChild(child)  // span 요소 제거
    ```
    
    - **왜 사용?**: 특정 요소를 DOM에서 삭제하고 싶을 때 사용.
    - **어떻게 사용?**: 부모 요소에서 `removeChild`를 사용하여 자식 요소를 제거한다.

## 4. 스타일 조작 ‘style’ property

- 해당 요소의 모든 style 속성 목록을 포함하는 속성
  ```jsx
const element = document.querySelector('.box')
element.style.backgroundColor = 'red'
```