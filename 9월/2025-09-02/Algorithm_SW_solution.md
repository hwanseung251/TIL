문제를 해결할 때 항상 정해진 절차를 따른다

복잡도를 분석해서 적은 시간 안에 계산이 끝나도록 알고리즘을 설계한다

SW 문제해결: 어떤 순서로?

복잡도 분석: 무슨 조건으로 다음 순서를 고려할까?

# SW 문제해결

- SW 문제해결 역량
    - 프로그램을 하기 위한 많은 제약 조건과 요구 사항을 이해하고 최선의 방법을 찾아내는 능력
    - 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 퍼즐을 배치하듯 이들을 연결하여 큰 그림을 만드는 능력이라 할 수 있음
    - 문제해결 역량은 추상적인 기술
    - 문제해결 과정
        1. 문제를 읽고 이해한다
        2. 문제를 익숙한 용어로 재정의한다 (완벽한 이해를 위해)
        3. 어떻게 해결할지 계획을 세운다
            - 설계 - 1. 자료구조
                
                           2. 알고리즘 
                
        4. 계획을 검증한다
            - 검증 - 복잡도
        5. 프로그램으로 구현한다
        6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다

### SW 문제해결 능력을 기르는 이유

- 코딩을 더 잘하게 하는 능력을 기르기 위함
- SWEA 문제를 통해 기본문법 & 자료구조 & 알고리즘을 더 능숙하게 쓸 수 있도록 훈련함

### SWEA 문제를 잘 풀기 위한 전략

- 단계 1: 완벽한 문제 이해
- 단계 2: 종이와 펜을 이용한 설계하기 (어떻게 구현할지 계획하기)
- 단계 3: 설계 한대로 구현 & 디버깅

## 복잡도 분석

### 알고리즘이란?

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
    - 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말함
- 간단하게 다시 말하면 어떠한 문제를 해결하기 위한 절차라고 볼 수 있음
- 1부터 100까지의 합을 구하는 두 가지 알고리즘의 예

### 알고리즘의 효율

- 공간적 효율성과 시간적 효율성
- 공간적 효율성은 알고리즘이 필요로 하는 메모리 공간
- 시간적 효율성은 알고리즘이 작업을 완료하는 데 걸리는 시간
- 효율성을 뒤집어 표현하면 복잡도가 됨. 복잡도가 높을수록 효율성은 저하됨

### 복잡도의 점근적 표기

- 시간 (또는 공간) 복잡도는 입력 크기에 대한 함수로 표기
    - 이 함수는 주로 여러 개의 항을 가지는 다항식
    - 이를 단순한 함수로 표현하기 위해 점근적 표기를 사용
- 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법
    - **O(Big-Oh) - 표기** ⇒ “최악”을 고려
        - ex) 1 ≤ N ≤ 100,000 이면 N이 100,000이라고 가정하고 한다.
    - Big-Omega 표기
    - Big-Theta 표기

### O(Big-Oh) - 표기

- O-표기는 복잡도의 점근적 상한을 나타냄
- 복잡도가 $f(n) = 2n^2 -7n +4$ 이라면,  $f(n)$의 O-표기는  $O(n^2)$
- 먼저 $f(n)$의 단순화된 표현은 $n^2$
- 단순화된 함수 $n^2$에 임의의 상수 c를 곱한 $cn^2$이  $n$이 증가함에 따라  $f(n)$의 상한이 된다 (단, c>0)

N의 범위를 항상 잘 봐야함!!

문제 풀이 에서는 최고차항 생략X

### 자주 사용하는 O-표기

- $O(1)$ : 상수 시간
- $O(logn)$ : 로그(대수) 시간 ⇒ 탐색 범위가 “반”으로 줄어듬
- $O(n)$ : 선형 시간
- $O(nlogn)$ : 로그 선형 시간
- $O(n^2)$ : 제곱 시간
- $O(n^3)$ : 세제곱 시간

$O(n)$  이해하기

- 만약 N이 10,000 이고 O(N)으로 짠 알고리즘이 있다면, 몇 번 반복하는 프로그램이라고 추정해도 될까?
    
    정답: 10000회
    

만약 $O(n^2)$ 라면?

- 만약 N이 10,000 이고 $O(n^2)$으로 짠 알고리즘이 있다면, 몇 번 반복하는 프로그램이라고 추정해도 될까?
    
    정답: 100,000,000회
    

만약 $O(logn)$ 라면?

- 만약 N이 10,000 이고 $O(logn)$으로 짠 알고리즘이 있다면, 몇 번 반복하는 프로그램이라고 추정해도 될까?
    
    정답: 13.2877..
    

## 우리는 이것을 어떻게 활용할 수 있을까?

ex) 50개 테스트케이스를 합쳐서 C언어는 1초 / python은 3초

```python
for i in range(100,000,000):  # ==> 몇 초?
		print(i)
# ==> PC 마다 속도가 다르게 나올 것 
# 때문에, 코테에서는 대략적인 시간을 약속해놓았음!!
```

같은 코드가 PC 성능에 따라 걸리는 시간이 다르기 때문에 실제 걸리는 시간으로 알고리즘 성능을 체크하는 건 의미가 X

코딩테스트에서는 연산 횟수에 따른 대략적인 시간을 약속

- C언어 기준 1초 당 1억 번 연산 가능
- Python언어 C언어보다 느리다
    
    → 1초 당 3,000만 번 정도 연산 가능 / 3초 당 1억 번 정도 연산 가능
    

즉 50개 테스트케이스를 합쳐서 python은 3초는 1억 / 50 ⇒ 하나 당 2백만 번 연산을 해야겠구나

```python
x = 2000
for _ in range(x):
		for _ in range(x):
				pass
=> 2000 x 2000은 4000000이니까 이중 포문쓰면 시간초과가 나겠구나!
```

### pypy vs python3

pypy: 반목문 등의 연산은 빠르다

python3: 메모리를 효율적으로 활용

코테는 pypy로 연습하는게 좋음

append() → 최대한 가능하다면 사용을 피하는 것이 좋다

적어도 10000번이상이 발생하면 append말고 다른방식으로 하는게 좋음

데이터 10만개가 들어올 것이다.

```python
li = []
for i in range(100,000):
		li.append() # => 이렇게 말고 
```

```python
li = [0] * 100,000
idx = 0
for i in range(100,000):
		li[idx] = input()
		idx += 1
```

### 표준 입출력

```python
import sys
# stdin : standard input(표준 입력)
# open() : 파일을 열겠다
sys.stdin = open("파일명")
```

shift + f10

필수 역량!!

→ A형 + 코테(히든 TC를 만들줄 알아야 함!)

1. 문제에서 숨겨진 히든 TC를 찾을 수 있어야 한다

(제공된 TC말고 히든 TC를 찾아야한다) 

1. 여러 TC를 내가 만들고 돌려야 하는데

—> input.txt를 활용해야 한다

---

# **진수 (Number System)**

# **1. 진법이란?**

## **1.1 개념: 숫자를 묶어 세는 단위**

**진법(進法)**은 **'숫자를 몇 개씩 묶어 다음 자릿수로 올리는가'**에 대한 약속이다. 우리가 일상에서 사용하는 **10진법**은 0부터 9까지 10개의 숫자를 사용하며, 10이 되는 순간 '십'이라는 새로운 자리로 올린다.

컴퓨터 과학에서는 목적에 따라 다양한 진법을 사용한다.

- **10진법 (Decimal):** 0~9
- **2진법 (Binary):** 0, 1 (컴퓨터가 데이터를 처리하는 방식 )
- **8진법 (Octal):** 0~7
- **16진법 (Hexadecimal):** 0~9, A~F (컴퓨터의 데이터를 사람이 보기 쉽게 표현)

## **1.2 왜 다른 진법을 배울까?**

컴퓨터는 모든 정보를 **0과 1의 조합(2진법)**으로만 이해한다. 하지만 2진수는 `11111001`처럼 조금만 수가 커져도 매우 길어져서 사람이 다루기 어려움.

이때 **16진법**을 사용하면 긴 2진수를 **네 자리씩 끊어** `F9`처럼 매우 간결하게 표현할 수 있음. 이것이 바로 우리가 2진법과 16진법 변환을 배우는 가장 중요한 이유임.

- **컴퓨터:** 내부적으로 2진수로 동작
- **개발자:** 컴퓨터의 데이터(2진수)를 간결하게 표현하고 읽기 위해 16진수를 활용 (예: 메모리 주소, 파일 시그니처, 색상 코드 `#FF0000`)

---

# **2. 진법 변환의 원리 (직접 계산)**

파이썬 내장 함수를 사용하기 전에, 변환 원리를 직접 이해하는 것은 문제 해결 능력에 큰 도움이 됨.

## **2.1 10진수** ➡️ **다른 진법으로 바꾸기**

<aside>
💡

바꾸고 싶은 진법의 숫자로 **계속 나누고, 나머지를 거꾸로** 읽는다.

</aside>

**예시: 10진수 ‘13’을 2진수로 변환**

1. `13 ÷ 2 = 6` ... **나머지 1**
2. `6 ÷ 2 = 3` ... **나머지 0**
3. `3 ÷ 2 = 1` ... **나머지 1**
4. `1 ÷ 2 = 0` ... **나머지 1** (몫이 0이 되면 종료)
    - 나머지를 아래에서 위로 거꾸로 읽으면 **`1101`** (2진수)
        
        ```python
        # 변환할 10진수 숫자
        target_num = 13
        
        # 2진수의 각 자릿수를 담을 리스트
        binary_digits = []
        
        # target_num이 0보다 큰 동안 계속 반복
        while target_num > 0:
            # 2로 나눈 나머지를 구함 (이것이 2진수의 현재 자릿수가 됨)
            remainder = target_num % 2
            binary_digits.append(remainder)
            
            # 다음 계산을 위해 target_num을 2로 나눈 몫으로 갱신
            target_num //= 2
        
        # 나머지를 거꾸로 뒤집어야 올바른 2진수가 됨
        binary_digits.reverse()
        
        print(f"10진수 13을 2진수로 변환: {binary_digits}")
        ```
        

## **2.2 다른 진법** ➡️ **10진수로 바꾸기**

<aside>
💡

각 자릿수에 해당하는 **진법의 거듭제곱을 곱하여** 모두 더한다.

</aside>

**예시: 2진수 `1101`을 10진수로 변환**

- 각 자릿수의 값: `(1 × $2^3$) + (0 × $2^2$) + (1 × $2^1$) + (1 × $2^0$)` → `8, 4, 2, 1`
- 계산: `(1 × 8) + (1 × 4) + (0 × 2) + (1 × 1)` = `8 + 4 + 0 + 1` = **13 (10진수)**
    
    ```python
    # 변환할 2진수 문자열
    binary_str = '1101'
    # 최종 10진수 값을 저장할 변수
    decimal_result = 0
    
    # 2진수 문자열의 각 자리를 왼쪽부터 순회
    for bit in binary_str:
        # 1. 기존 결과값에 2를 곱하여 자릿수를 하나씩 왼쪽으로 이동시킴
        #    (예: 1 -> 2, 3 -> 6, 6 -> 12)
        decimal_result *= 2
        
        # 2. 현재 자릿수의 숫자를 더함
        #    '1'이면 1을, '0'이면 0을 더함
        if bit == '1':
            decimal_result += 1
    
    print(decimal_result) # 13
    ```
    
    - 코드 실행 과정
        
        
        | 반복 | 현재 bit | `decimal_result *= 2` 실행 후 | `if bit == '1'` 실행 후 |
        | --- | --- | --- | --- |
        | 1 | `'1'` | `0 * 2 = 0` | `0 + 1 = 1` |
        | 2 | `'1'` | `1 * 2 = 2` | `2 + 1 = 3` |
        | 3 | `'0'` | `3 * 2 = 6` | (변화 없음) `6` |
        | 4 | `'1'` | `6 * 2 = 12` | `12 + 1 = 13` |

---

# **3. 2진수** ↔️ **16진수 빠른 변환 (핵심)**

2진수와 16진수는 `$2^4=16$` 이라는 관계 때문에 매우 쉽게 상호 변환이 가능함.

> **2진수 4자리**는 **16진수 1자리**와 완벽하게 일치함.
> 

| 16진수 | 2진수 (4자리) | 10진수 |
| --- | --- | --- |
| 0 | 0000 | 0 |
| 1 | 0001 | 1 |
| ... | ... | ... |
| 9 | 1001 | 9 |
| A | 1010 | 10 |
| B | 1011 | 11 |
| C | 1100 | 12 |
| D | 1101 | 13 |
| E | 1110 | 14 |
| F | 1111 | 15 |

## **3.1 16진수** ➡️ **2진수로 바꾸기**

**예시: 16진수 `A7`을 2진수로 변환**

1. `A`를 2진수 4자리로 → `1010`
2. `7`을 2진수 4자리로 → `0111`
3. 두 결과를 이어 붙이면 → **`10100111`**

## **3.2 2진수** ➡️ **16진수로 바꾸기**

**예시: 2진수 `11110010`을 16진수로 변환**

1. 오른쪽부터 4자리씩 끊기 → `1111` / `0010`
2. `1111`을 16진수로 → `F`
3. `0010`을 16진수로 → `2`
4. 두 결과를 이어 붙이면 → **`F2`**

---

# **4. 파이썬을 활용한 진법 변환**

<aside>
💡

원리를 이해했다면, 실제 코드에서는 파이썬의 강력한 내장 함수들을 활용하는 것이 좋음.

</aside>

## **4.1 다른 진법 문자열** ➡️ **10진수 정수**

### 4.1.1 `int()`

- **`int(string, base)`**: `base` 진법으로 표현된 `string`을 10진수 정수로 변환함.
    
    ```python
    # 2진수 '1101'을 10진수로
    
    decimal_from_binary = int('1101', 2)
    print(decimal_from_binary)  # 13
    ```
    
    ```python
    # 16진수 'A7'을 10진수로 (접두어 '0x'는 있어도 되고 없어도 됨)
    
    decimal_from_hex = int('A7', 16)
    print(decimal_from_hex)     # 167
    print(int('0xA7', 16))      # 167
    ```
    
    ```python
    # 8진수 '15'를 10진수로
    
    decimal_from_octal = int('15', 8)
    print(decimal_from_octal)   # 13
    ```
    

## **4.2 10진수 정수** ➡️ **다른 진법 문자열**

### 4.2.1 `bin` / `hex` / `oct`

- **`bin(number)`**: 10진수를 `0b` 접두어가 붙은 2진수 문자열로 변환함.
- **`hex(number)`**: 10진수를 `0x` 접두어가 붙은 16진수 문자열로 변환함.
- **`oct(number)`**: 10진수를 `0o` 접두어가 붙은 8진수 문자열로 변환함.
    
    ```python
    num = 167
    
    # 10진수 167을 각 진법으로 변환
    print(bin(num))  # '0b10100111'
    print(hex(num))  # '0xa7'
    print(oct(num))  # '0o247'
    ```
    
    ```python
    # 접두어를 제거하고 싶다면 슬라이싱을 활용
    print(bin(num)[2:]) # '10100111'
    ```
    

## 4.3 `format()`

- **`format(number, 'b/o/x')`**
    1. **접두어 없이 순수한 진법 문자열**을 얻고 싶거나, 
        
        ```python
        num = 13
        
        # 접두어 없는 순수한 진법 문자열
        print(format(num, 'b'))  # '1101'
        print(format(num, 'x'))  # 'd' (소문자)
        print(format(num, 'X'))  # 'D' (대문자)
        ```
        
    2. **자릿수를 맞추고 싶을 때** 매우 유용함.
        
        ```python
        # 8자리 2진수로 표현하고, 남는 공간은 0으로 채우기
        print(format(num, '08b')) # '00001101'
        ```
        

## **4.4 `zfill()`로 더 쉽게 자릿수 맞추기**

<aside>
💡

`format()`과 `zfill()` 중 더 익숙하고 편한 방법을 선택하여 사용하면 됨.

</aside>

- 문자열 메서드 `.zfill(width)`을 사용하면, 자릿수 채우기를 더 직관적으로 할 수 있음.
- 'zero fill'의 약자로, 문자열의 길이가 `width`보다 작을 경우 **남는 앞 공간을 `0`으로 채워줌.**
- `bin()`, `hex()` 등으로 변환한 결과 문자열에서 접두어(`0b`, `0x`)를 잘라낸 뒤 `zfill()`을 사용하면 `format()`과 동일한 결과를 얻을 수 있음.
    
    ```python
    num = 13
    
    # 1. bin()으로 2진수 문자열로 변환 ('0b1101')
    # 2. [2:] 슬라이싱으로 접두어 '0b' 제거 ('1101')
    # 3. .zfill(8)으로 전체 길이를 8자리로 맞추고 앞을 0으로 채움
    binary_str = bin(num)[2:].zfill(8)
    
    print(binary_str) # 출력: 00001101
    ```
    

---

# 5. 10진수를 거쳐가기

<aside>
💡

2진수와 16진수 간 변환은 내장 함수를 이용해 **중간에 10진수를 거쳐 변환**하는 것이 가장 **간결하고 안전함**. 파이썬의 내장 함수는 이미 C언어 수준에서 고도로 최적화되어 있어 매우 빠르기 때문.

</aside>

- **16진수 'A7'** ➡️ **10진수** ➡️ **2진수 변환 과정 예시**
    
    ```python
    # 1. 16진수 문자열 'A7'을 10진수 정수로 변환
    decimal_value = int('A7', 16)  # 167
    
    # 2. 10진수 정수 167을 2진수 문자열로 변환
    binary_string = bin(decimal_value)
    
    print(binary_string)      # '0b10100111'
    print(binary_string[2:])  # '10100111'
    
    ```