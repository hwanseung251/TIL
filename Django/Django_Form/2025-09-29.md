## HTML ‘form’

- 지금까지 사용자로부터 데이터를 제출 받기위해 활용한 방법.
- 그러나 비정상적 혹은 악의적인 요청을 필터링 할 수 없다
    
    

 유효한 데이터인지에 대한 확인이 필요하다 !

<aside>
💡

유효성 검사

- 수집한 데이터가 정확하고 유효한지 확인하는 과정

유효성 검사 구현은 어려움

- 유효성 검사를 구현하기 위해서는 입력 값, 형식, 중복, 범위, 보안 등 많은 것들을 고려해야 함
- 이런 과정과 기능을 직접 개발하는 것이 아닌 Django가 제공하는 Form을 사용

→ Django Form이 자동으로 올바른 형식인지 점검하는 기능을 제공함

</aside>

## Form Class

### Django Form(Form class를 상속받아 사용한다!)

- 사용자 입력 데이터를 수집하고, 처리 및 유효성 검사를 수행하기 위한 도구
- 유효성 검사를 단순화, 자동화 할 수 있는 기능을 제공
- 사용자가 잘못 입력한 데이터는 자동으로 오류로 처리되어 안전성을 높음
- 개발자는 이를 통해 빠르고 일관된 입력 검증 기능을 구현할 수 있음

```python
# forms.py 생성 
class ArticleForm(forms.Form):
    title = forms.CharField(max_length=10) # models와 이름만 같을 뿐 다른 클래스임 
    content = forms.CharFiel) # forms에는 TextField가 존재하지 않는다
```

```python
# articles/views.py
from .forms import ArticleForm

def new(request):
    """새로운 게시글을 작성할 수 있는 new.html 페이지를 렌더링"""
    # 사용자가 데이터를 입력할 수 있는 빈 form 페이지를 보여주는 역할만 함
    form = ArticleForm()
    context = {
        'form': form,
    }
    return render(request, 'articles/new.html', context)
```

```html
<!-- articles/new.html -->

<h1>NEW</h1>
<form action="{% url 'articles:create' %}" method="POST">
	{% csrf token %}
	{{ form }}
	<input type="submit">
</form>
```

- HTML의 form을 아예 대체 하는 게 아닌, 그 안에 있는 input을 대체함

### Widgets

- forms.py에서 클래스를 정의할 때, content가 Textarea임을 표현해야 하는데,,, forms에는 없었음
    - Widgets으로 표현 !!
- HTML ‘input’ element의 표현을 담당

```python
# forms.py 생성 
class ArticleForm(forms.Form):
    title = forms.CharField(max_length=10) # models와 이름만 같을 뿐 다른 클래스임 
    content = forms.CharField(widget=forms.Textarea) 
```

### Django ModelForm

- **Form VS ModelForm**
    - Form: 사용자 입력 데이터를 DB에 저장하지 않을 때
        - 검색, 로그인
    - ModelForm: 사용자 입력 데이터를 DB에 저장해야 할 때
        - 게시글 작성, 회원가입

우월 관계가 아니라 용도가 서로 다른 것

### ModelForm

- Model과 연결된 Form을 자동으로 생성해주는 기능을 제공한다.
    - Form클래스와 Model클래스를 결합한 형태로, 모델 필드(models.py에 있는)를 기반으로 입력 폼을 자동 생성해준다
    - 즉, 데이터 수집과 저장 과정을 동시에 처리할 수 있도록 도와줌!

```python
from django import forms
from .models import Article

class ArticleForm(forms.ModelForm):
    class Meta: # 메타데이터: 데이터에 대한 데이터, 즉 추가 정보를 적음 
        model = Article
        fields = '__all__'
```

- models.py에서 정의한 모델만 주었을 뿐인데 title, content, widget 등 다 적용이 자동으로 됨
- class Meta..?
    - ModelForm의 정보를 작성하는 곳
        - ModelForm 내부에서 어떤 모델과 연결할지, 어떤 필드를 사용할지 등을 정의하는 설정 공간
        - fields 및 exclude 속성(on off 개념이라고 생각하면 됨)
            - `fields = '__all__'` : 모두 사용
            - `fields = ('title',)` : title 만 사용
            - `exclude = ('title',)` : title 만 제외
    - 주의사항
        - 파이썬의 inner class와 같은 문법적인 관점으로 접근하지 말 것

### ModelForm 적용

```python
# articles/views.py

from .forms import ArticleForm

def create(request):
		form = ArticleForm(request.POST)
		if form.is_valid():
				article = form.save()
				return redirect('articles:detail', article.pk) # url을 부름
		context = {
				'form' : form,
		}
		return render(request, 'articles/new.html', context) # html을 부름 
```

- 공백 데이터가 유효하지 않은 이유와 에러메시지가 출력되는 과정
    - 별도로 명시하지 않았지만 모델 필드에는 기본적으로 빈 값은 허용하지 않는 제약조건이 설정됨
    - 빈 값은 `is_valid()`에 의해 False로 평가되고 form 객체에는 그에 맞는 에러 메세지가 포함되어 다음 코드로 진행됨

### ModelForm을 적용 edit 로직

```python
# views.py
def edit(request, pk):
    """기존 게시글을 수정할 수 있는 edit.html 페이지를 렌더링"""
    # 1. 수정할 게시글의 기존 데이터를 pk를 이용해 조회
    article = Article.objects.get(pk=pk)
    form = ArticleForm(instance=article) # 수정할때 원래 데이터 표시해주는건 instance에 전달하기!

    # 2. 조회된 데이터를 form에 미리 채워넣기 위해 context에 담아 템플릿에 전달
    context = {
        'article': article,
        'form': form,
    }
    # 3. edit.html 템플릿을 렌더링
    return render(request, 'articles/edit.html', context)
```

```html
<!-- articles/edit.html -->

<h1>EDIT</h1>
<form action="{% url 'articles:update' article.pk %}" method="POST">
	{% csrf_token %}
	{{ form }}
	<input type="submit">
</form>
```

### ModelForm을 적용한 update 로직

```python
# articles/views.py

def update(request, pk):
    """사용자가 form을 통해 제출한 수정 데이터를 DB에 반영(UPDATE)"""
    # 1. 수정할 게시글을 pk를 이용해 조회
    article = Article.objects.get(pk=pk)
    # 2. 사용자가 입력한(수정한) 데이터를 통째로 받음 + 기존 데이터를 넣어줘야 save메서드가 갱신로직을 진행함
    form = ArticleForm(request.POST, instance=article) # instance가 없으면 save메서드가 생성로직으로 인식해서 데이터를 생성함 

    # 3. 유효성검사
    if form.is_valid():
        # 3.1 검사 통과 했을 때
        form.save()
        return redirect('articles:detail', article.pk)
    # 3.2 검사 통과 못했을 때
    context = {
        'article': article,
        'form': form, 
    }
    return render(request, 'articles/edit.html', context)
```

### save 메서드

- 데이터베이스 객체를 만들고 저장하는 ModelForm의 인스턴스 메서드
- 특징
    - 폼 데이터가 유효한 경우, save() 메서드를 호출하면 모델 인스턴스를 생성하고 데이터베이스에 저장됨
    - instance 인자를 통해 새 객체 생성과 기존 객체 수정을 구분
    
    ```python
    # CREATE
    
    form = ArticleForm(request.POST)
    form.save()
    ```
    
    ```python
    # UPDATE
    
    form = ArticleForm(request.POST, instance=article)
    form.save()
    ```
    
    - 이 과정을 통해 코드 없이 손쉽게 DB 연동 가능

## View 함수 구조 변화

### new & create view 함수간 공통점과 차이점

- 공통점
    - “데이터 생성을 구현하기 위함”
- 차이점
    - “new는 GET method 요청만을, create는 POST method 요청만을 처리”

### HTTP request method 차이점을 활용해 동일한 목적을 가지는 2개의 view 함수를 하나로 구조화

```python
def new(request):
		form = ArticleForm()
		context = {
				'form': form,
		}
		return render(request, 'articles/new.html', context)
```

```python
def create(request):
		form = ArticleForm(request.POST)
		if form.is_valid():
				article = form.save()
				return redirect('articles:detail', article.pk)
		
		context = {
				'form': form,
		}
		return render(request, 'articles/new.html', context)
```

두개를 합치면?

```python
def create(request):
		if request.method == 'POST':
				form = ArticleForm(request.POST)
				if form.is_valid():
						article = form.save()
						return redirect('articles:detail', article.pk)
		else:
				form = ArticleForm()
		context = {
				'form': form,
		}		
		return render(request, 'articles/new.html', context)
```

그럼 이제 new url을 사용하지 않게 되었으니 new url 제거 

html 파일에서 new 관련 키워드를 create로 변경(create하나로 합쳤기 때문) 

### 기존 edit과 update view 함수 결합

- 위와 유사함
```python
def update(request, pk):
		article = Article.objects.get(pk=pk)
		if request.method == 'POST':
				form = ArticleForm(request.POST, instance=article)
				if form.is_valid():
						form.save()
						return redirect('articles:detail', article.pk)
		else:
				form = ArticleForm(instance=article)
		context = {
				'article' : article,
				'form': form,
		}
		return render(request, 'articles/update.html', context)
```