### Login 에서…

- Authentication Form 은 Form(ModelForm아님)
    - Form/ModelForm 둘다 공통점은 사용자 입력을 받는 다는 것
    - 차이점은 받은 값을 DB에 넣을거냐 말거냐. ModelForm은 넣고 Form은 인증 수단으로 쓰고 넣지 않음

- 세션을 만드는 것 자체는 login함수임
    - login함수 안에 있는 Authentication은  인증된 사용자인지 확인하는 역할 (입구같은 느낌?)

## Logout

- CRUD에서 D임.
    - 로그인에서 만든 세션 데이터를 지우는 것
    - 클라이언트의 세션 쿠키도 삭제 (총 두 개 삭제)
    

로그아웃 경로 url 생성

```python
app_name = 'accounts'
urlpatterns = [
    path('login/', views.login, name='login'),
    path('logout/', views.logout, name='logout'),
```

/accounts/logout/url로 요청이 들어왔을 때 실행할 logout 함수 작성

- 로그아웃은 삭제이지만 조회를 하지 않는다!!
    
    이미 request안에 User정보가 있기 때문..
    

```python
from django.contrib.auth import logout as auth_logout

def logout(request):
    # 누가 로그아웃하는지 유저를 조회해야 하는가?
    # => 요청 객체(request)에 이미 유저 정보가 담겨있어서 조회할 필요가 없다
    # print(request.user)
    # 해당 유저의 세션을 삭제 
    auth_logout(request)
    return redirect('articles:index')
```

- user는 request안에 user관련 정보가 들어있어서 DB를 조회하는 과정이 필요없음

html에 로그아웃 폼 작성 

```html
    <form action="{% url 'accounts:logout' %}" method="POST">
      {% csrf_token %}
      <input type="submit" value="Logout">
    </form>
```

## AbstractUser class

**Abstract base classes(추상 기본 클래스) → ‘틀’ 역할**

- 몇 가지 공통 정보를 여러 다른 모델에 넣을 때 사용하는 클래스
- 데이터베이스 테이블을 만드는 데 사용되지 않으며, 대신 다른 모델의 기본 클래스로 사용되는 경우 해당 필드가 하위 클래스의 필드에 추가 됨
- 인증에 필요한 최소한의 기능만 제공

**AbstractUser class**

- 관리자 권한과 함께 완전한 기능을 가지고 있는 User model을 구현하는 추상 기본클래스
- 기본 User 모델이 가진 모든 필드가 이미 구현되어 있음

추상 클래스는 migrate가 되지 않기 때문에(틀의 역할만함) 우리가 수정을 하기 위해서 `class User` 로 커스텀해서 사용하는 것이다   

| 구분 | AbstractBaseUser | AbstractUser |
| --- | --- | --- |
| 제공 필드 | 최소한의 인증 필드(비밀번호, last_login 등) | 기본 User 모델의 모든 필드(username, email 등) |
| 장점  | 최대의 유연성과 자유도 | 개발 속도가 빠르고 편리함 |
| 사용 케이스 | 이메일이 아닌 전화번호 등으로 로그인하는 등, 완전히 새로운 인증 체계를 만들 때 | 기존 인증 방식은 유지하면서 프로필 사진, 닉네임 등 필드만 추가하고 싶을 때(대부분의 경우) |
| 예시 | 기본 피자 도우 | 토핑이 올려진 피자  |

‘Abstrack’있으면 ‘DB에 migrate되지 않고 기본적인 기능 만을 제공해주는 애들이구나’ 라고 생각하자.

추상클래스이기때문에 완전한 기능을 가지는 User에서 **AbstractUser class**를 따와서 ****사용, 그래야 커스텀(테이블이 생성되기 때문에)이 가능.

---

## 회원 가입

- CRUD 에서 C임
    - USER를 CREATE하는 과정
- 이것도 built-in Form 이 존재함. 이거는 ModelForm임(DB에 들어가기 때문에)
- 페이지를 만드는 GET, 유저생성 POST 두개 동작필요

```python
app_name = 'accounts'
urlpatterns = [
		path('signup/', views.signup, name='signup'),
]
```

```python
from django.contrib.auth.forms import UserCreationForm

def signup(request):
		if request.method == "POST":
				form = UserCreationForm(request.POST)
				if form.is_valid():
						form.save()
						return redirect("articles:index")
		else:
				# 회원가입 폼
				form = UserCreationForm()
		context = {
				'form': form,
		}
		return render(request, 'accounts/signup.html', context)
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>회원가입</h1>
    <form action="{% url "accounts:signup" %}" method="POST">
        {% csrf_token %}
        {{ form }}
        <input type="submit">
    </form>
</body>
</html>
```

이렇게 까지 하면 에러가 뜸(아래에서 설명)

### 회원 가입 로직 에러

- Manager isn’t available; ‘auth.User’ has been swapped for ‘accounts.User’
- 회원가입에 사용하는 UserCreationForm이 대체한 커스텀 유저 모델이 아닌 과거 Django의 기본 유저 모델로 인해 작성된 클래스이기 때문
    - model에 Custom User Model을 연결하자!

```python
# accounts/forms.py
from django.contrib.auth import get_user_model

class CustomUserCreationForm(UserCreationForm):
		class Meta(UserCreationForm.Meta):
				model = get_user_model()
```

- Custom User model을 사용할 수 있도록 상속 후 일부분만 재작성

`get_user_model()`

현재 프로젝트에서 활성화된 사용자 모델을 반환하는 함수

- 프로젝트 설정(AUTH_USER_MODEL)에 따라 기본 User 모델일 수도, 우리가 직접 만든 커스텀 User 모델일 수도 있기 때문에 올바른 모델을 동적으로 가져오기 위해 사용
- User모델이 바뀌어도 코드를 수정할 필요가 없어 재사용성과 유연성이 높아진다

**즉 User 모델을 직접 참조하지 않는다! 라고만 알고 나중에 다룸**

```python
#from django.contrib.auth.forms import UserCreationForm
from .forms import CustomUserCreationForm

def signup(request):
		if request.method == "POST":
				form = CustomUserCreationForm(request.POST)
				if form.is_valid():
						form.save()
						return redirect("articles:index")
		else:
				# 회원가입 폼
				form = CustomUserCreationForm()
		context = {
				'form': form,
		}
		return render(request, 'accounts/signup.html', context)
```

finish!!

---

## 회원 탈퇴

```python
app_name = 'accounts'
urlpatterns = [
		path('delete/', views.delete, name='delete'),
]
```

```python
def delete(request):
		# 누구를 탈퇴하는지에 대한 유저 조회는 불필요
		request.user.delete()
		return redirect('articles:index')
```

회원 탈퇴를 하면 세션은 남아있지만(세션 삭제는 로그아웃) 이 토큰을 보내도 그 유저가 삭제되어서 무용지물이 되는 것.

---

## 인증된 사용자에 대한 접근 제한

비회원과 회원/ 비인증과 인증에 대한 구분이 가능해졌다

1. `is_authenticated` 속성 
2. `login_required` 데코레이터 

을 활용해서 구별해보자

### is_authenticated 속성

- 인증 사용자에 대해서는 항상 True
- 비인증 사용자(Anonymouse User)에 대해서는 항상 False

```html
# setting에 TEMPLATES.OPTIONS 가보면 request 그아래 user가 존재함 
# request를 안써도 되긴함. 명시적으로 쓰기 위함임 
{% if request.user.is_authenticated %}
	<form action='{% url 'accounts:logout' %}' method="POST">
		{% csrf_token %}
		<input type='submit' value='Logout'>
	</form>
	<form action='{% url 'accounts:delete' %}' method="POST">
		{% csrf_token %}
		<input type='submit' value='회원탈퇴'>
	</form>
{% else %}
	<a href="{% url "accounts:login" %}">Login</a>
	<a href="{% url "accounts:signup" %}">회원가입</a>
{% endif %}
```

하지만 아직 눈속임에 불과하다!

→ 주소를 입력하면 들어갈 수 는 있음

즉, 궁극적으로 막진 못함

**궁극적으로 막으려면 view 함수쪽을 막아야 함**

```python
def login(request):
    if request.user.is_authenticated:
        return redirect('articles:index')
        
        
def signup(request):
    if request.user.is_authenticated:
        return redirect('articles:index')
```

주소를 알아도 인증된 사용자이면 redirect되어서 들어갈 수 없게 됨 

### login_required 데코레이터

- 비인증 사용자의 경우 /accounts/login/ 주소로 redirect시킴
```python
# articles/views.py
from django.contrib.auth.decorators import login_required

@login_required
def create(request):
		...

@login_required
def delete(request. pk):
		...
		
@login_required
def update(request, pk):
		... 
```

```python
# accounts/views.py
from django.contrib.auth.decorators import login_required

@login_required
def logout(request):
		...

@login_required
def delete(request. pk):
		...
```